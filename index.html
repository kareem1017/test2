<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Runner 3D — Mobile + Settings + Leaderboard</title>
<style>
  :root { --bg:#0b0f14; --fg:#e5e7eb; --panel:#111827; --glass:rgba(0,0,0,.55); --accent:#2563eb; --muted:#9ca3af; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font:14px system-ui,Segoe UI,Roboto; overflow:hidden }
  #hud { position:fixed; top:12px; left:12px; z-index:10; background:rgba(0,0,0,.35); padding:8px 12px; border-radius:10px; backdrop-filter: blur(6px); }
  #hud b { font-weight:700; }
  #btnTop { position:fixed; top:12px; right:12px; display:flex; gap:8px; z-index:12 }
  .topBtn { padding:8px 10px; border-radius:10px; border:0; background:#1f2937; color:#fff; font-weight:700 }
  #hint { position:fixed; bottom:12px; left:12px; opacity:.85 }
  .overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:var(--glass); z-index:20 }
  .card { background:var(--panel); padding:22px 26px; border-radius:16px; min-width:min(94vw,640px) }
  .row { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px }
  button { padding:10px 14px; border-radius:12px; border:0; background:var(--accent); color:white; font-weight:700; cursor:pointer }
  button.ghost { background:#1f2937 }
  label { display:flex; align-items:center; justify-content:space-between; gap:12px; margin:10px 0 }
  input[type="range"] { width:260px }
  .note { color:var(--muted); font-size:12px }
  #mobileControls { position:fixed; bottom:20px; width:100%; display:flex; justify-content:space-between; pointer-events:none; z-index:12 }
  .mcBtn { background:rgba(0,0,0,0.45); padding:30px; border-radius:50%; pointer-events:auto; font-size:28px; color:white; user-select:none; }
  ol { margin:6px 0 0 18px }
</style>
</head>
<body>

<div id="hud">Score: <b id="score">0</b> | Time: <b id="time">0.0</b>s | Speed: <b id="spd">0</b></div>
<div id="btnTop">
  <button id="pauseBtn" class="topBtn">Pause</button>
  <button id="openSettingsBtn" class="topBtn">Settings</button>
</div>
<div id="hint">Swipe L/R to change lanes, swipe ↑ to jump • Or use the big buttons • Avoid red blocks • Collect green orbs</div>

<!-- Menu -->
<div id="menu" class="overlay" style="display:flex">
  <div class="card">
    <h1 style="margin:0 0 6px">Runner 3D</h1>
    <p class="note" style="margin:0 0 10px">Mobile-friendly, adjustable settings, local leaderboard.</p>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="menuSettingsBtn" class="ghost">Settings</button>
    </div>
    <div style="margin-top:12px">
      <b>Top Scores</b>
      <ol id="leaderMenu"></ol>
    </div>
  </div>
</div>

<!-- Pause -->
<div id="pause" class="overlay">
  <div class="card">
    <h2 style="margin:0 0 8px">Paused</h2>
    <div class="row">
      <button id="resumeBtn">Resume</button>
      <button id="pauseSettingsBtn" class="ghost">Settings</button>
      <button id="restartBtn" class="ghost">Restart</button>
      <button id="toMenuBtn" class="ghost">Menu</button>
    </div>
  </div>
</div>

<!-- Settings -->
<div id="settings" class="overlay">
  <div class="card">
    <h2 style="margin:0 0 8px">Settings</h2>
    <div>
      <label>Base Speed (u/s) <span><output id="baseOut">2.0</output></span></label>
      <input id="base" type="range" min="1.0" max="6.0" step="0.1" value="2.0">

      <label>Speed Ramp (u/s²) <span><output id="rampOut">0.18</output></span></label>
      <input id="ramp" type="range" min="0.00" max="0.60" step="0.02" value="0.18">

      <label>Max Speed (u/s) <span><output id="maxOut">5.0</output></span></label>
      <input id="max" type="range" min="2.0" max="10.0" step="0.1" value="5.0">

      <label>Gravity (u/s²) <span><output id="gravOut">-18</output></span></label>
      <input id="grav" type="range" min="-30" max="-10" step="1" value="-18">

      <label>Jump Strength (u/s) <span><output id="jumpOut">10.5</output></span></label>
      <input id="jump" type="range" min="6.0" max="16.0" step="0.1" value="10.5">

      <label>Spawn Density (spawns/sec) <span><output id="densOut">0.40</output></span></label>
      <input id="dens" type="range" min="0.00" max="1.00" step="0.02" value="0.40">

      <label>Grace Period (seconds) <span><output id="graceOut">2.5</output></span></label>
      <input id="grace" type="range" min="0.0" max="5.0" step="0.1" value="2.5">

      <label>Camera Follow (per s) <span><output id="camOut">6.0</output></span></label>
      <input id="cam" type="range" min="1.0" max="12.0" step="0.5" value="6.0">
    </div>
    <p class="note">Most settings apply immediately. Grace period is re-applied when you restart.</p>
    <div class="row">
      <button id="settingsSave">Save</button>
      <button id="settingsClose" class="ghost">Close</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameover" class="overlay">
  <div class="card">
    <h2>Game Over</h2>
    <p>Score: <span id="finalScore">0</span></p>
    <div>
      <b>Top Scores</b>
      <ol id="leaderGo"></ol>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="goRestartBtn">Restart</button>
      <button id="goMenuBtn" class="ghost">Menu</button>
      <button id="goSettingsBtn" class="ghost">Settings</button>
    </div>
  </div>
</div>

<!-- Mobile Controls -->
<div id="mobileControls">
  <div class="mcBtn" id="btnLeft">⬅️</div>
  <div class="mcBtn" id="btnJump">⬆️</div>
  <div class="mcBtn" id="btnRight">➡️</div>
</div>

<canvas id="webgl"></canvas>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* --------- Settings state --------- */
const settings = {
  base: 2.0, ramp: 0.18, max: 5.0,
  gravity: -18, jump: 10.5,
  density: 0.40,             // spawns per second
  grace: 2.5,                // seconds of invulnerability at start
  camFollow: 6.0             // per-second smoothing
};
const $ = id => document.getElementById(id);
const bindOut = (inp, out, fmt=1) => inp.oninput = () => out.textContent = (+inp.value).toFixed(fmt);
bindOut(base, baseOut, 1); bindOut(ramp, rampOut, 2); bindOut(max, maxOut, 1);
bindOut(grav, gravOut, 0); bindOut(jump, jumpOut, 1); bindOut(dens, densOut, 2);
bindOut(grace, graceOut, 1); bindOut(cam, camOut, 1);

function syncSettingsToUI() {
  base.value  = settings.base;  baseOut.textContent  = settings.base.toFixed(1);
  ramp.value  = settings.ramp;  rampOut.textContent  = settings.ramp.toFixed(2);
  max.value   = settings.max;   maxOut.textContent   = settings.max.toFixed(1);
  grav.value  = settings.gravity; gravOut.textContent= settings.gravity.toFixed(0);
  jump.value  = settings.jump;  jumpOut.textContent  = settings.jump.toFixed(1);
  dens.value  = settings.density; densOut.textContent= settings.density.toFixed(2);
  grace.value = settings.grace; graceOut.textContent = settings.grace.toFixed(1);
  cam.value   = settings.camFollow; camOut.textContent= settings.camFollow.toFixed(1);
}
function saveSettingsFromUI() {
  settings.base = +base.value;
  settings.ramp = +ramp.value;
  settings.max  = +max.value;
  settings.gravity = +grav.value;
  settings.jump    = +jump.value;
  settings.density = +dens.value;
  settings.grace   = +grace.value;
  settings.camFollow = +cam.value;
}

/* --------- Three.js --------- */
const canvas = $('webgl');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: innerWidth > 768 });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0b0f14, 1);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 3.3, 7);

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(5, 8, 6);
scene.add(dir);

const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(120, 36),
  new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 1 })
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

/* --------- Player --------- */
const player = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  new THREE.MeshStandardMaterial({ color: 0x3b82f6, metalness:.1, roughness:.6 })
);
player.position.set(0, 0.5, 0);
scene.add(player);

/* --------- Entities --------- */
const obstacles = [];
const pickups = [];
const oGeo = new THREE.BoxGeometry(1,1,1);
const oMat = new THREE.MeshStandardMaterial({ color: 0xef4444, roughness:.5 });
const pGeo = new THREE.SphereGeometry(0.35, 24, 16);
const pMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive:0x0a2, emissiveIntensity: .6 });

let lastSpawnZ = -28;
function spawnLine(z) {
  // maintain min spacing
  if (z - lastSpawnZ > -8) z = lastSpawnZ - 8;
  lastSpawnZ = z;

  const lanes = [-2, 0, 2];
  const count = 1 + Math.floor(Math.random()*2); // 1..2 obstacles (fair)
  for (let i=0; i<count; i++) {
    const lane = lanes.splice(Math.floor(Math.random()*lanes.length),1)[0];
    const o = new THREE.Mesh(oGeo, oMat);
    o.position.set(lane, 0.5, z);
    obstacles.push(o);
    scene.add(o);
  }
  if (lanes.length > 0 && Math.random() < 0.65) {
    const lane = lanes[Math.floor(Math.random()*lanes.length)];
    const p = new THREE.Mesh(pGeo, pMat);
    p.position.set(lane, 0.5, z - 3);
    pickups.push(p);
    scene.add(p);
  }
}

/* --------- Helpers --------- */
const scoreEl = $('score'), timeEl = $('time'), spdEl = $('spd');
const overUI = $('gameover'), finalScoreEl = $('finalScore');
const leaderMenu = $('leaderMenu'), leaderGo = $('leaderGo');
const LB_KEY = 'runnerLB_v3';
const loadLB  = () => JSON.parse(localStorage.getItem(LB_KEY) || '[]');
const saveLB  = lb => localStorage.setItem(LB_KEY, JSON.stringify(lb));
function renderLB(target, src=null) {
  const lb = src || loadLB();
  target.innerHTML = lb.map(s=>`<li>${s}</li>`).join('');
}

/* --------- Game state --------- */
let lane = 0, vy = 0;
let speed = settings.base;
let score = 0, running = false, paused = false;
let startTime = 0, invulnUntil = 0;
let spawnAcc = 0; // seconds accumulator for spawn rate

/* --------- Flow --------- */
function resetWorld() {
  // clear
  for (const arr of [obstacles, pickups]) while (arr.length) scene.remove(arr.pop());
  lastSpawnZ = -28;
  // safe initial rows (far away)
  [-16, -24, -32, -40, -48].forEach(z => spawnLine(z));

  lane = 0; vy = 0; speed = settings.base; score = 0;
  startTime = performance.now();
  invulnUntil = startTime + settings.grace*1000;
  spawnAcc = 0;
  player.position.set(0,0.5,0);

  scoreEl.textContent = '0';
  timeEl.textContent = '0.0';
  spdEl.textContent = speed.toFixed(2);
}

function startGame() {
  $('menu').style.display='none';
  overUI.style.display='none';
  $('pause').style.display='none';
  resetWorld();
  running = true; paused = false;
}

function endGame() {
  running = false; paused = false;
  finalScoreEl.textContent = score;
  let lb = loadLB(); lb.push(score); lb.sort((a,b)=>b-a); lb = lb.slice(0,5); saveLB(lb);
  renderLB(leaderMenu, lb); renderLB(leaderGo, lb);
  overUI.style.display='flex';
}

function setPaused(p) {
  paused = p;
  $('pause').style.display = p ? 'flex' : 'none';
}

/* --------- Input --------- */
const keys = new Set();
addEventListener('keydown', e => {
  if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','Escape'].includes(e.code)) e.preventDefault();
  keys.add(e.code);
  if (e.code === 'Escape' && running) setPaused(!paused);
}, {passive:false});
addEventListener('keyup', e => keys.delete(e.code), {passive:true});

$('btnLeft').onclick  = ()=> lane = Math.max(-2, lane-2);
$('btnRight').onclick = ()=> lane = Math.min(+2, lane+2);
$('btnJump').onclick  = ()=> { if (Math.abs(player.position.y-0.5) < 0.001) vy = settings.jump; };

let touchStartX=0, touchStartY=0;
addEventListener('touchstart', e => { touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; }, {passive:true});
addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 30) lane = Math.min(+2, lane+2);
    else if (dx < -30) lane = Math.max(-2, lane-2);
  } else if (dy < -30 && Math.abs(player.position.y-0.5) < 0.001) {
    vy = settings.jump;
  }
}, {passive:true});

/* --------- Buttons --------- */
$('startBtn').onclick = startGame;
$('restartBtn').onclick = startGame;
$('goRestartBtn').onclick = startGame;
$('toMenuBtn').onclick = () => { setPaused(false); running=false; $('menu').style.display='flex'; };
$('goMenuBtn').onclick = () => { running=false; $('menu').style.display='flex'; overUI.style.display='none'; };
$('pauseBtn').onclick = () => { if (running) setPaused(!paused); };
$('resumeBtn').onclick = () => setPaused(false);

$('menuSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('pauseSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('openSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; setPaused(true); };
$('goSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('settingsSave').onclick = () => { saveSettingsFromUI(); $('settings').style.display='none'; };
$('settingsClose').onclick = () => { $('settings').style.display='none'; };

renderLB(leaderMenu); $('menu').style.display='flex';

/* --------- Update / Render --------- */
function update(dt) {
  if (!running || paused) return;

  // inputs (lane/jump)
  if ((keys.has('ArrowLeft')||keys.has('KeyA'))  && lane > -2) { lane -= 2; keys.delete('ArrowLeft'); keys.delete('KeyA'); }
  if ((keys.has('ArrowRight')||keys.has('KeyD')) && lane <  2) { lane += 2; keys.delete('ArrowRight'); keys.delete('KeyD'); }
  if ((keys.has('Space')||keys.has('ArrowUp')||keys.has('KeyW')) && Math.abs(player.position.y-0.5) < 0.001) {
    vy = settings.jump; keys.delete('Space'); keys.delete('ArrowUp'); keys.delete('KeyW');
  }

  // smooth lane snap
  const kx = 1 - Math.exp(-12 * dt); // faster horizontal snap
  player.position.x += (lane - player.position.x) * kx;

  // vertical motion
  vy += settings.gravity * dt;
  player.position.y += vy * dt;
  if (player.position.y < 0.5) { player.position.y = 0.5; vy = 0; }

  // world forward
  obstacles.forEach(o => o.position.z += speed * dt);
  pickups.forEach(p   => p.position.z += speed * dt);

  // cleanup
  for (let i=obstacles.length-1; i>=0; i--) if (obstacles[i].position.z > 10) { scene.remove(obstacles[i]); obstacles.splice(i,1); score += 5; }
  for (let i=pickups.length-1; i>=0; i--)   if (pickups[i].position.z   > 10) { scene.remove(pickups[i]);   pickups.splice(i,1); }

  // spawn pacing: use density (spawns/sec)
  spawnAcc += dt;
  const expected = settings.density * spawnAcc;
  if (expected >= 1) {
    for (let i=0; i<Math.floor(expected); i++) spawnLine(-36 - Math.random()*12);
    spawnAcc = expected - Math.floor(expected);
  } else if (Math.random() < expected) {
    spawnLine(-36 - Math.random()*12);
    spawnAcc = 0;
  }

  // collisions — only when grounded and after grace
  const now = performance.now();
  const grounded = player.position.y <= 0.7;
  if (now > invulnUntil && grounded) {
    for (const o of obstacles) {
      const hitXZ = Math.abs(player.position.x - o.position.x) < 0.9 && Math.abs(player.position.z - o.position.z) < 0.9;
      if (hitXZ) return endGame();
    }
  }
  for (let i=pickups.length-1; i>=0; i--) {
    const p = pickups[i];
    const hit = Math.abs(player.position.x - p.position.x) < 0.9 &&
                Math.abs(player.position.y - p.position.y) < 0.9 &&
                Math.abs(player.position.z - p.position.z) < 0.9;
    if (hit) { score += 20; scene.remove(p); pickups.splice(i,1); }
  }

  // ramp speed
  speed = Math.min(settings.max, speed + settings.ramp * dt);

  // HUD
  scoreEl.textContent = score;
  timeEl.textContent  = ((now - startTime)/1000).toFixed(1);
  spdEl.textContent   = speed.toFixed(2);
}

function render(dt) {
  // camera follow
  const k = 1 - Math.exp(-settings.camFollow * dt);
  const target = new THREE.Vector3(player.position.x*0.5, 3.3, 7);
  camera.position.lerp(target, k);
  camera.lookAt(player.position.x, 0.8, player.position.z - 2);

  renderer.render(scene, camera);
}

let last = performance.now();
function loop(now) {
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;
  update(dt);
  render(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* --------- Resize --------- */
addEventListener('resize', () => {
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>