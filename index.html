<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Runner 3D ‚Äî Visibility + Pro Power-ups</title>
<style>
  :root { --bg:#0b0f14; --fg:#e5e7eb; --panel:#111827; --glass:rgba(0,0,0,.55); --accent:#2563eb; --muted:#9ca3af; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font:14px system-ui,Segoe UI,Roboto; overflow:hidden }
  #hud { position:fixed; top:12px; left:12px; z-index:10; background:rgba(0,0,0,.35); padding:8px 12px; border-radius:10px; backdrop-filter: blur(6px); }
  #hud b { font-weight:700; }
  #btnTop { position:fixed; top:12px; right:260px; display:flex; gap:8px; z-index:12 }
  .topBtn { padding:8px 10px; border-radius:10px; border:0; background:#1f2937; color:#fff; font-weight:700 }
  #hint { position:fixed; bottom:12px; left:12px; opacity:.85 }
  .overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:var(--glass); z-index:20 }
  .card { background:var(--panel); padding:22px 26px; border-radius:16px; min-width:min(94vw,640px) }
  .row { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px }
  button { padding:10px 14px; border-radius:12px; border:0; background:var(--accent); color:white; font-weight:700; cursor:pointer }
  button.ghost { background:#1f2937 }
  label { display:flex; align-items:center; justify-content:space-between; gap:12px; margin:10px 0 }
  input[type="range"], input[type="text"] { width:260px }
  .note { color:var(--muted); font-size:12px }

  #mobileControls { position:fixed; bottom:20px; width:100%; display:flex; justify-content:space-between; pointer-events:none; z-index:12 }
  .mcBtn { background:rgba(0,0,0,0.45); padding:30px; border-radius:50%; pointer-events:auto; font-size:28px; color:white; user-select:none; }

  /* Leaderboard dock */
  #leaderDock {
    position:fixed; top:0; right:0; width:240px; height:100%;
    background:rgba(0,0,0,.35); backdrop-filter: blur(6px);
    padding:12px; box-sizing:border-box; z-index:11;
    border-left:1px solid rgba(255,255,255,.06);
  }
  #leaderDock h3 { margin:6px 0 6px; font-size:16px }
  #leaderDock ol { margin:8px 0 0 18px }
  #leaderDock .name { color:#93c5fd }
  #powerups { margin-top:10px; font-size:12px; color:var(--muted) }
  #playerNameDisplay { font-size:12px; color:var(--muted); margin-bottom:6px }
</style>
</head>
<body>

<div id="hud">
  Score: <b id="score">0</b> |
  Time: <b id="time">0.0</b>s |
  Speed: <b id="spd">0</b> |
  Shield: <b id="shieldHud">0</b>
</div>
<div id="btnTop">
  <button id="pauseBtn" class="topBtn">Pause</button>
  <button id="openSettingsBtn" class="topBtn">Settings</button>
</div>
<div id="hint">Swipe L/R or use buttons ‚Ä¢ Swipe ‚Üë / Space to jump ‚Ä¢ Avoid red capsules ‚Ä¢ Collect green orbs</div>

<aside id="leaderDock">
  <div id="playerNameDisplay"></div>
  <h3>Top Scores</h3>
  <ol id="leaderList"></ol>
  <div id="powerups">
    <div>Dash: <span id="dashT">0.0</span>s</div>
    <div>Magnet: <span id="magnetT">0.0</span>s</div>
  </div>
</aside>

<!-- Name prompt -->
<div id="nameAsk" class="overlay">
  <div class="card" style="min-width:min(94vw,420px)">
    <h2 style="margin:0 0 8px">Enter Player Name</h2>
    <p class="note">Used for the leaderboard. You can change it later in Settings.</p>
    <input id="nameInput" type="text" placeholder="Your name" maxlength="24" style="width:100%; padding:10px; border-radius:10px; border:1px solid #374151; background:#0b1220; color:#e5e7eb; margin:8px 0 12px">
    <div class="row">
      <button id="nameSave">Save</button>
    </div>
  </div>
</div>

<!-- Menu -->
<div id="menu" class="overlay" style="display:none">
  <div class="card">
    <h1 style="margin:0 0 6px">Runner 3D</h1>
    <p class="note" style="margin:0 0 10px">Mobile-friendly, adjustable settings, local leaderboard.</p>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="menuSettingsBtn" class="ghost">Settings</button>
    </div>
  </div>
</div>

<!-- Pause -->
<div id="pause" class="overlay">
  <div class="card">
    <h2 style="margin:0 0 8px">Paused</h2>
    <div class="row">
      <button id="resumeBtn">Resume</button>
      <button id="pauseSettingsBtn" class="ghost">Settings</button>
      <button id="restartBtn" class="ghost">Restart</button>
      <button id="toMenuBtn" class="ghost">Menu</button>
    </div>
  </div>
</div>

<!-- Settings -->
<div id="settings" class="overlay">
  <div class="card">
    <h2 style="margin:0 0 8px">Settings</h2>
    <div>
      <label>Player Name <input id="playerNameInp" type="text" maxlength="24" placeholder="Your name"></label>

      <label>Base Speed (u/s) <span><output id="baseOut">18.0</output></span></label>
      <input id="base" type="range" min="10.0" max="60.0" step="0.5" value="18.0">

      <label>Speed Ramp (u/s¬≤) <span><output id="rampOut">1.70</output></span></label>
      <input id="ramp" type="range" min="0.00" max="3.00" step="0.05" value="1.70">

      <label>Max Speed (u/s) <span><output id="maxOut">40.0</output></span></label>
      <input id="max" type="range" min="20.0" max="60.0" step="0.5" value="40.0">

      <label>Gravity (u/s¬≤) <span><output id="gravOut">-21</output></span></label>
      <input id="grav" type="range" min="-40" max="-5" step="1" value="-21">

      <label>Jump Strength (u/s) <span><output id="jumpOut">10.8</output></span></label>
      <input id="jump" type="range" min="6.0" max="20.0" step="0.1" value="10.8">

      <label>Spawn Density (spawns/sec) <span><output id="densOut">1.46</output></span></label>
      <input id="dens" type="range" min="0.00" max="2.50" step="0.02" value="1.46">

      <label>Grace Period (seconds) <span><output id="graceOut">1.7</output></span></label>
      <input id="grace" type="range" min="0.0" max="5.0" step="0.1" value="1.7">

      <label>Camera Follow (per s) <span><output id="camOut">6.0</output></span></label>
      <input id="cam" type="range" min="1.0" max="12.0" step="0.5" value="6.0">

      <label><span>Only collide when grounded</span><input id="colGround" type="checkbox"></label>
    </div>
    <p class="note">Most settings apply immediately. Grace re-applies on restart. Name saved to localStorage.</p>
    <div class="row">
      <button id="settingsSave">Save</button>
      <button id="settingsClose" class="ghost">Close</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameover" class="overlay">
  <div class="card">
    <h2>Game Over</h2>
    <p>Score: <span id="finalScore">0</span></p>
    <div class="row" style="margin-top:10px">
      <button id="goRestartBtn">Restart</button>
      <button id="goMenuBtn" class="ghost">Menu</button>
      <button id="goSettingsBtn" class="ghost">Settings</button>
    </div>
  </div>
</div>

<!-- Mobile Controls -->
<div id="mobileControls">
  <div class="mcBtn" id="btnLeft">‚¨ÖÔ∏è</div>
  <div class="mcBtn" id="btnJump">‚¨ÜÔ∏è</div>
  <div class="mcBtn" id="btnRight">‚û°Ô∏è</div>
</div>

<canvas id="webgl"></canvas>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- Storage & settings ---------- */
const LB_KEY = 'runner_lb_v8';
const NAME_KEY = 'runner_name_v1';
const ST_KEY = 'runner_settings_v8';

const DEFAULTS = {
  base: 18.0, ramp: 1.70, max: 40.0,
  gravity: -21, jump: 10.8,
  density: 1.46,
  grace: 1.7,
  camFollow: 6.0,
  collideGroundedOnly: false
};

const $ = id => document.getElementById(id);
const outBind = (inp, out, d=1) => inp.oninput = () => out.textContent = (+inp.value).toFixed(d);

let settings = { ...DEFAULTS, ...(JSON.parse(localStorage.getItem(ST_KEY)||'{}')) };
function syncSettingsToUI() {
  base.value=settings.base; baseOut.textContent=settings.base.toFixed(1);
  ramp.value=settings.ramp; rampOut.textContent=settings.ramp.toFixed(2);
  max.value=settings.max;   maxOut.textContent=settings.max.toFixed(1);
  grav.value=settings.gravity; gravOut.textContent=settings.gravity.toFixed(0);
  jump.value=settings.jump; jumpOut.textContent=settings.jump.toFixed(1);
  dens.value=settings.density; densOut.textContent=settings.density.toFixed(2);
  grace.value=settings.grace; graceOut.textContent=settings.grace.toFixed(1);
  cam.value=settings.camFollow; camOut.textContent=settings.camFollow.toFixed(1);
  colGround.checked = !!settings.collideGroundedOnly;
  playerNameInp.value = localStorage.getItem(NAME_KEY)||'';
}
function saveSettingsFromUI() {
  settings.base=+base.value; settings.ramp=+ramp.value; settings.max=+max.value;
  settings.gravity=+grav.value; settings.jump=+jump.value; settings.density=+dens.value;
  settings.grace=+grace.value; settings.camFollow=+cam.value; settings.collideGroundedOnly=!!colGround.checked;
  localStorage.setItem(ST_KEY, JSON.stringify(settings));
  const newName = playerNameInp.value.trim();
  if (newName) localStorage.setItem(NAME_KEY, newName);
  refreshNameDisplay();
}
outBind(base,baseOut,1); outBind(ramp,rampOut,2); outBind(max,maxOut,1);
outBind(grav,gravOut,0); outBind(jump,jumpOut,1); outBind(dens,densOut,2);
outBind(grace,graceOut,1); outBind(cam,camOut,1);

/* ---------- Leaderboard ---------- */
const leaderList = $('leaderList');
function getLB(){ return JSON.parse(localStorage.getItem(LB_KEY)||'[]'); }
function pushLB(name,score){ const lb=getLB(); lb.push({name,score,at:Date.now()}); lb.sort((a,b)=>b.score-a.score); localStorage.setItem(LB_KEY, JSON.stringify(lb.slice(0,5))); renderLB(); }
function renderLB(){
  const lb=getLB();
  leaderList.innerHTML = lb.slice(0,5).map(x=>`<li><span class="name">${(x.name||'Anon')}</span>: ${x.score}</li>`).join('');
}

/* ---------- Name ---------- */
function refreshNameDisplay(){
  const n = localStorage.getItem(NAME_KEY)||'';
  $('playerNameDisplay').textContent = n ? `Player: ${n}` : 'Player: (not set)';
}
(function ensureName(){
  const n = localStorage.getItem(NAME_KEY)||'';
  if (!n) { $('nameAsk').style.display='flex'; }
  else { $('menu').style.display='flex'; }
})();
$('nameSave').onclick = ()=>{
  const v = $('nameInput').value.trim(); if (!v) return;
  localStorage.setItem(NAME_KEY, v);
  $('nameAsk').style.display='none'; $('menu').style.display='flex'; refreshNameDisplay();
};
refreshNameDisplay(); renderLB();

/* ---------- Three.js ---------- */
const canvas = $('webgl');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: innerWidth > 768 });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0b0f14, 1);

const scene = new THREE.Scene();
/* Softer fog so you see ahead */
scene.fog = new THREE.FogExp2(0x0b0f14, 0.028);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 300);
camera.position.set(0, 3.3, 7);

/* Brighter, more readable lighting */
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(6, 10, 8); scene.add(dir);
/* Rim light from front so obstacles ‚Äúread‚Äù */
const rim = new THREE.PointLight(0xff5555, 0.8, 100, 2.0);
rim.position.set(0, 3, 6); scene.add(rim);

/* Bigger floor so horizon exists */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(260, 60),
  new THREE.MeshStandardMaterial({ color: 0x0f1420, roughness: 0.95, metalness:0.05 })
);
floor.rotation.x = -Math.PI/2; scene.add(floor);

/* ---------- Player: BALL ---------- */
const R = 0.5;
const player = new THREE.Mesh(
  new THREE.SphereGeometry(R, 28, 18),
  new THREE.MeshStandardMaterial({ color: 0x3b82f6, metalness:.45, roughness:.35, emissive:0x0a1e44, emissiveIntensity:.35 })
);
player.position.set(0, R, 0); scene.add(player);

/* ---------- Entities & materials ---------- */
const obstacles=[], pickups=[], powerups=[], halos=[], labels=[];
/* Capsule with ‚Äúfake outline‚Äù (scaled shell) for visibility */
const capGeo = new THREE.CapsuleGeometry(0.5, 1.0, 10, 16);
const capMat = new THREE.MeshStandardMaterial({ color: 0xff2e2e, emissive:0x390707, emissiveIntensity:.9, metalness:.35, roughness:.25 });
function makeCapsule(){
  const root = new THREE.Group();
  const body = new THREE.Mesh(capGeo, capMat);
  const shell = new THREE.Mesh(capGeo, new THREE.MeshBasicMaterial({ color: 0x000000, wireframe:true, opacity:0.35, transparent:true }));
  shell.scale.set(1.08,1.08,1.08);
  root.add(body); root.add(shell);
  root.userData.body = body; // for collisions
  return root;
}

const orbGeo = new THREE.SphereGeometry(0.38, 24, 16);
const orbMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive:0x0a2, emissiveIntensity: .95, metalness:.25, roughness:.35 });

/* Power-up meshes */
const shieldGeo = new THREE.TorusGeometry(0.52, 0.10, 18, 48);
const shieldMat = new THREE.MeshStandardMaterial({ color: 0x93c5fd, emissive:0x203a7a, emissiveIntensity:.95, metalness:.55, roughness:.25 });
const dashGeo   = new THREE.ConeGeometry(0.36, 0.9, 24);
const dashMat   = new THREE.MeshStandardMaterial({ color: 0x9b5cf0, emissive:0x3a1766, emissiveIntensity:.95, metalness:.45, roughness:.3 });
const magnetGeo = new THREE.TorusGeometry(0.55, 0.12, 20, 60, Math.PI);
const magnetMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive:0x4b2d00, emissiveIntensity:.95, metalness:.5, roughness:.3 });

/* Star halo + label sprites (canvas textures) */
function makeHaloSprite(size=1.8, color='#ffd166'){
  const c = document.createElement('canvas'); c.width = c.height = 256;
  const g = c.getContext('2d');
  const grad = g.createRadialGradient(128,128,20, 128,128,120);
  grad.addColorStop(0, color+'dd'); grad.addColorStop(0.35, color+'55'); grad.addColorStop(1, '#00000000');
  g.fillStyle = grad; g.beginPath(); g.arc(128,128,120,0,Math.PI*2); g.fill();
  // star spokes
  g.globalCompositeOperation='lighter';
  g.strokeStyle = color; g.lineWidth=3; 
  for(let i=0;i<5;i++){
    const a = (i/5)*Math.PI*2;
    const x = 128 + Math.cos(a)*110, y=128 + Math.sin(a)*110;
    g.beginPath(); g.moveTo(128,128); g.lineTo(x,y); g.stroke();
  }
  const tex = new THREE.CanvasTexture(c); tex.transparent=true;
  const mat = new THREE.SpriteMaterial({ map: tex, depthWrite:false, depthTest:true, transparent:true, opacity:0.8 });
  const spr = new THREE.Sprite(mat); spr.scale.set(size, size, 1);
  return spr;
}
function makeLabelSprite(text='‚òÖ', color='#ffffff'){
  const c = document.createElement('canvas'); c.width = 256; c.height = 128;
  const g = c.getContext('2d');
  g.font = '64px system-ui,Segoe UI,Roboto'; g.textAlign='center'; g.textBaseline='middle';
  g.fillStyle = color; g.shadowColor=color; g.shadowBlur=18;
  g.fillText(text, 128, 64);
  const tex = new THREE.CanvasTexture(c); tex.transparent=true;
  const mat = new THREE.SpriteMaterial({ map: tex, depthWrite:false, transparent:true });
  const spr = new THREE.Sprite(mat); spr.scale.set(1.2, 0.6, 1);
  return spr;
}

/* ---------- Spawning ---------- */
let lastSpawnZ = -60; // farther so they appear early
function spawnLine(z) {
  if (z - lastSpawnZ > -10) z = lastSpawnZ - 10;
  lastSpawnZ = z;

  const lanes = [-2, 0, 2];

  // time-based difficulty scaling: more motion & more pieces
  const t = Math.max(0, (performance.now() - startTime)/1000);
  const diff = Math.min(1.5, 0.6 + t/40); // 0.6 -> 1.5 over ~60s

  const baseCount = (Math.random() < 0.5 ? 1 : 2);
  const extra = Math.random() < Math.min(0.35*diff, 0.7) ? 1 : 0; // sometimes a 3rd
  const count = Math.min(lanes.length, baseCount + extra);

  for (let i=0; i<count; i++) {
    const lane = lanes.splice(Math.floor(Math.random()*lanes.length),1)[0];
    const o = makeCapsule();
    o.position.set(lane, 1.0, z);

    // motion profiles
    o.userData.phase = Math.random()*Math.PI*2;
    if (Math.random() < 0.85) {
      o.userData.vxAmp = (0.8 + Math.random()*1.4) * diff;
      o.userData.vxW   = 0.9 + Math.random()*1.6;
    }
    if (Math.random() < 0.55) {
      o.userData.vyAmp = 0.12 + Math.random()*0.2;
      o.userData.vyW   = 1.0 + Math.random()*1.2;
    }
    if (Math.random() < 0.35) {
      o.userData.swapTo = (Math.random()<0.5 ? -2 : 2);
      o.userData.swapSpeed = (0.35 + Math.random()*0.55) * diff;
    }

    obstacles.push(o); scene.add(o);
  }

  // rewards / power-ups (rarer)
  if (lanes.length > 0) {
    const lane = lanes[Math.floor(Math.random()*lanes.length)];
    const roll = Math.random();
    if (roll < 0.60) { // orbs most of the time
      const p = new THREE.Mesh(orbGeo, orbMat);
      p.position.set(lane, 0.6, z - 3); pickups.push(p); scene.add(p);
    } else if (roll < 0.64) { // 4% shield
      const s = new THREE.Mesh(shieldGeo, shieldMat);
      s.rotation.x = Math.PI/2; s.position.set(lane, 0.7, z - 3); s.userData.type='shield';
      addHaloAndLabel(s, '#7cc0ff', 'üõ°'); powerups.push(s); scene.add(s);
    } else if (roll < 0.68) { // 4% dash
      const d = new THREE.Mesh(dashGeo, dashMat);
      d.position.set(lane, 0.65, z - 3); d.userData.type='dash';
      addHaloAndLabel(d, '#c9a7ff', '‚ö°'); powerups.push(d); scene.add(d);
    } else if (roll < 0.72) { // 4% magnet
      const m = new THREE.Mesh(magnetGeo, magnetMat);
      m.rotation.z = Math.PI; m.position.set(lane, 0.7, z - 3); m.userData.type='magnet';
      addHaloAndLabel(m, '#ffd166', 'üß≤'); powerups.push(m); scene.add(m);
    } // else empty lane for breathing room
  }
}

/* attach halo/label for power-ups */
function addHaloAndLabel(obj, color, emoji){
  const halo = makeHaloSprite(2.1, color);
  halo.position.set(0, 0.05, 0);
  const label = makeLabelSprite(emoji, '#ffffff');
  label.position.set(0, 0.9, 0);
  obj.add(halo); obj.add(label);
  halos.push(halo); labels.push(label);
}

/* ---------- Helpers ---------- */
const scoreEl=$('score'), timeEl=$('time'), spdEl=$('spd'), shieldHud=$('shieldHud');
const dashT=$('dashT'), magnetT=$('magnetT');

function hitBallCapsule(ball, capGroup) {
  const cap = capGroup.userData.body || capGroup; // actual mesh
  const capR = 0.5, capHalf = 1.0;
  const dx = ball.x - cap.position.x - capGroup.position.x;
  const dz = ball.z - cap.position.z - capGroup.position.z;
  const distXZ = Math.hypot(dx, dz);
  const touchXZ = distXZ < (capR + R*0.98);
  const dy = Math.abs(ball.y - (cap.position.y + capGroup.position.y));
  const touchY = dy < capHalf + R*0.65;
  return touchXZ && touchY;
}

/* ---------- Game state ---------- */
let lane=0, vy=0, speed=settings.base, score=0, running=false, paused=false;
let startTime=performance.now(), invulnUntil=0, spawnAcc=0;
let shield=0, dashUntil=0, magnetUntil=0;

/* ---------- Input ---------- */
const keys = new Set();
addEventListener('keydown', e => {
  if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','Escape'].includes(e.code)) e.preventDefault();
  keys.add(e.code);
  if (e.code === 'Escape' && running) setPaused(!paused);
}, {passive:false});
addEventListener('keyup', e => keys.delete(e.code), {passive:true});

$('btnLeft').onclick  = ()=> lane = Math.max(-2, lane-2);
$('btnRight').onclick = ()=> lane = Math.min(+2, lane+2);
$('btnJump').onclick  = ()=> { if (Math.abs(player.position.y-R) < 0.001) vy = settings.jump; };

let touchStartX=0, touchStartY=0;
addEventListener('touchstart', e => { touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; }, {passive:true});
addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 30) lane = Math.min(+2, lane+2);
    else if (dx < -30) lane = Math.max(-2, lane-2);
  } else if (dy < -30 && Math.abs(player.position.y-R) < 0.001) {
    vy = settings.jump;
  }
}, {passive:true});

/* ---------- Buttons ---------- */
$('startBtn').onclick = startGame;
$('restartBtn').onclick = startGame;
$('goRestartBtn').onclick = startGame;
$('toMenuBtn').onclick = () => { setPaused(false); running=false; $('menu').style.display='flex'; };
$('goMenuBtn').onclick = () => { running=false; $('menu').style.display='flex'; $('gameover').style.display='none'; };
$('pauseBtn').onclick = () => { if (running) setPaused(!paused); };
$('resumeBtn').onclick = () => setPaused(false);

$('menuSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('pauseSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('openSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; setPaused(true); };
$('goSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('settingsSave').onclick = () => { saveSettingsFromUI(); $('settings').style.display='none'; };
$('settingsClose').onclick = () => { $('settings').style.display='none'; };

/* ---------- Flow ---------- */
function resetWorld(){
  for (const arr of [obstacles,pickups,powerups]) while (arr.length) scene.remove(arr.pop());
  lastSpawnZ = -80; // even farther for visibility at start
  for (let z=-40; z>=-140; z-=12) spawnLine(z);
  lane=0; vy=0; speed=settings.base; score=0; shield=0; shieldHud.textContent='0';
  dashUntil=0; magnetUntil=0; dashT.textContent='0.0'; magnetT.textContent='0.0';
  startTime = performance.now();
  invulnUntil = startTime + settings.grace*1000;
  spawnAcc = 0;
  player.position.set(0,R,0);
  scoreEl.textContent='0'; timeEl.textContent='0.0'; spdEl.textContent=settings.base.toFixed(2);
}
function startGame(){
  $('menu').style.display='none'; $('gameover').style.display='none'; $('pause').style.display='none';
  resetWorld(); running=true; paused=false;
}
function endGame(){
  running=false; paused=false;
  const name = localStorage.getItem(NAME_KEY)||'Anon';
  $('finalScore').textContent = score;
  pushLB(name, score);
  renderLB();
  $('gameover').style.display='flex';
}
function setPaused(p){ paused=p; $('pause').style.display = p ? 'flex' : 'none'; }

/* ---------- Update / Render ---------- */
function update(dt){
  if (!running || paused) return;
  const now = performance.now();

  // inputs
  if ((keys.has('ArrowLeft')||keys.has('KeyA'))  && lane > -2) { lane -= 2; keys.delete('ArrowLeft'); keys.delete('KeyA'); }
  if ((keys.has('ArrowRight')||keys.has('KeyD')) && lane <  2) { lane += 2; keys.delete('ArrowRight'); keys.delete('KeyD'); }
  if ((keys.has('Space')||keys.has('ArrowUp')||keys.has('KeyW')) && Math.abs(player.position.y-R) < 0.001) {
    vy = settings.jump; keys.delete('Space'); keys.delete('ArrowUp'); keys.delete('KeyW');
  }

  // smooth lane snap
  const kx = 1 - Math.exp(-12 * dt);
  player.position.x += (lane - player.position.x) * kx;

  // vertical motion
  vy += settings.gravity * dt;
  player.position.y += vy * dt;
  if (player.position.y < R) { player.position.y = R; vy = 0; }

  // obstacle motion (wiggle + bob + optional lane drift)
  for (const o of obstacles){
    const p = o.userData;
    const baseY = 1.0;
    if (p.vxAmp) o.position.x += Math.sin(now/1000*p.vxW + p.phase) * p.vxAmp * dt;
    if (p.vyAmp) o.position.y = baseY + Math.sin(now/1000*p.vyW + p.phase) * p.vyAmp;
    if (p.swapTo !== undefined) {
      const toward = p.swapTo - o.position.x;
      o.position.x += Math.sign(toward) * Math.min(Math.abs(toward), p.swapSpeed * dt * 60) * 0.02;
    }
    o.position.x = Math.max(-2.6, Math.min(2.6, o.position.x));
  }

  // power-up timers
  const dashActive = now < dashUntil;
  const magnetActive = now < magnetUntil;
  dashT.textContent = Math.max(0, (dashUntil-now)/1000).toFixed(1);
  magnetT.textContent = Math.max(0, (magnetUntil-now)/1000).toFixed(1);

  // world forward
  const worldFactor = dashActive ? 1.25 : 1.0;
  obstacles.forEach(o => o.position.z += speed * worldFactor * dt);
  pickups.forEach(p   => p.position.z += speed * worldFactor * dt);
  powerups.forEach(pu => pu.position.z += speed * worldFactor * dt);

  // magnet attraction
  if (magnetActive){
    for (const p of pickups){
      const dx = player.position.x - p.position.x;
      const dy = player.position.y - p.position.y;
      const dz = (player.position.z - 1) - p.position.z;
      const dist = Math.hypot(dx,dy,dz);
      if (dist < 4){
        const pull = (4 - dist) * 2.3;
        p.position.x += (dx/(dist+1e-6)) * pull * dt;
        p.position.y += (dy/(dist+1e-6)) * pull * dt;
        p.position.z += (dz/(dist+1e-6)) * pull * dt;
      }
    }
  }

  // cleanup
  const clean = arr => { for (let i=arr.length-1;i>=0;i--) if (arr[i].position.z > 12) { scene.remove(arr[i]); arr.splice(i,1); } };
  for (let i=obstacles.length-1;i>=0;i--) if (obstacles[i].position.z > 12){ scene.remove(obstacles[i]); obstacles.splice(i,1); score+=5; }
  clean(pickups); clean(powerups);

  // spawn pacing + difficulty over time (more rows as time increases)
  spawnAcc += dt * (1 + Math.min(1.6, ((now - startTime)/1000) / 35)); // ramps quicker than before
  const expected = settings.density * spawnAcc;
  if (expected >= 1) {
    for (let i=0; i<Math.floor(expected); i++) spawnLine(-60 - Math.random()*30);
    spawnAcc = expected - Math.floor(expected);
  }

  // collisions ‚Äî instant death unless shield (dash avoids death)
  const grounded = player.position.y <= (R + 0.2);
  const canDie = now > invulnUntil && (!settings.collideGroundedOnly || grounded) && !dashActive;

  if (canDie){
    for (let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      if (hitBallCapsule(player.position, o)) {
        if (shield > 0){
          shield--; shieldHud.textContent=String(shield);
          scene.remove(o); obstacles.splice(i,1);
          invulnUntil = now + 150;
        } else {
          return endGame();
        }
      }
    }
  }

  // pickups
  for (let i=pickups.length-1;i>=0;i--){
    const p=pickups[i];
    const dx = player.position.x - p.position.x;
    const dy = player.position.y - p.position.y;
    const dz = player.position.z - p.position.z;
    if (Math.hypot(dx,dy,dz) < (R + 0.6)){ score+=20; scene.remove(p); pickups.splice(i,1); }
  }
  for (let i=powerups.length-1;i>=0;i--){
    const pu=powerups[i];
    const dx = player.position.x - pu.position.x;
    const dy = player.position.y - pu.position.y;
    const dz = player.position.z - pu.position.z;
    if (Math.hypot(dx,dy,dz) < (R + 0.7)){
      if (pu.userData.type==='shield'){ shield++; shieldHud.textContent=String(shield); }
      else if (pu.userData.type==='dash'){ dashUntil = now + 2500; }
      else if (pu.userData.type==='magnet'){ magnetUntil = now + 5000; }
      scene.remove(pu); powerups.splice(i,1);
    }
  }

  // ramp speed
  speed = Math.min(settings.max, speed + settings.ramp * dt);

  // HUD
  scoreEl.textContent = score;
  timeEl.textContent  = ((now - startTime)/1000).toFixed(1);
  spdEl.textContent   = speed.toFixed(2);
}

function render(dt){
  const k = 1 - Math.exp(-settings.camFollow * dt);
  const target = new THREE.Vector3(player.position.x*0.5, 3.3, 7);
  camera.position.lerp(target, k);
  camera.lookAt(player.position.x, 0.8, player.position.z - 2);
  renderer.render(scene, camera);
}

let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000); last = now;
  update(dt); render(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ---------- Resize ---------- */
addEventListener('resize', () => {
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
});
</script>
</body>
</html>
