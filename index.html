<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Runner 3D — Night Run + Crescents</title>
<style>
  :root { --bg:#0b0f14; --fg:#e5e7eb; --panel:#111827; --glass:rgba(0,0,0,.55); --accent:#2563eb; --muted:#9ca3af; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font:14px system-ui,Segoe UI,Roboto; overflow:hidden }
  #hud { position:fixed; top:12px; left:12px; z-index:20; background:rgba(0,0,0,.35); padding:8px 12px; border-radius:10px; backdrop-filter: blur(6px); }
  #hud b { font-weight:700; }
  #btnTop { position:fixed; top:12px; right:12px; display:flex; gap:8px; z-index:20 }
  .topBtn { padding:8px 10px; border-radius:10px; border:0; background:#1f2937; color:#fff; font-weight:700 }
  #hint { position:fixed; bottom:12px; left:12px; opacity:.85; z-index:10 }
  .overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:var(--glass); z-index:30 }
  .card { background:var(--panel); padding:22px 26px; border-radius:16px; min-width:min(94vw,640px) }
  .row { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px }
  button { padding:10px 14px; border-radius:12px; border:0; background:var(--accent); color:white; font-weight:700; cursor:pointer }
  button.ghost { background:#1f2937 }
  label { display:flex; align-items:center; justify-content:space-between; gap:12px; margin:10px 0 }
  input[type="range"], input[type="text"] { width:260px }
  .note { color:var(--muted); font-size:12px }

  /* Mobile controls */
  #mobileControls { position:fixed; bottom:20px; width:100%; display:flex; justify-content:space-between; pointer-events:none; z-index:12 }
  .mcBtn { background:rgba(0,0,0,0.45); padding:30px; border-radius:50%; pointer-events:auto; font-size:28px; color:white; user-select:none; }

  /* Leader dock (collapsible on phones) */
  #leaderDock {
    position:fixed; top:0; right:0; width:260px; height:100%;
    background:rgba(0,0,0,.35); backdrop-filter: blur(6px);
    padding:12px; box-sizing:border-box; z-index:15;
    border-left:1px solid rgba(255,255,255,.06); transition: transform .25s ease;
  }
  #leaderDock h3 { margin:6px 0 6px; font-size:16px }
  #leaderDock ol { margin:8px 0 0 18px }
  #leaderDock .name { color:#93c5fd }
  #powerups { margin-top:10px; font-size:12px; color:var(--muted) }
  #playerNameDisplay { font-size:12px; color:var(--muted); margin-bottom:6px }
  #dockTab {
    position:fixed; right:0; top:50%; transform:translateY(-50%);
    z-index:16; background:#1f2937; color:#fff; padding:10px 8px;
    border-radius:10px 0 0 10px; font-weight:700; writing-mode:vertical-rl;
    text-orientation:mixed; letter-spacing:1px;
  }
  @media (max-width: 768px) {
    #leaderDock { transform: translateX(100%); width: 75vw; }
    #leaderDock.open { transform: translateX(0); }
    #dockTab { display:block; }
  }
  @media (min-width: 769px) { #dockTab { display:none; } }

  /* Power-up floating labels kept small; no HUD overlap */
  .labelHolder { pointer-events:none; }
</style>
</head>
<body>

<div id="hud">
  Score: <b id="score">0</b> |
  Time: <b id="time">0.0</b>s |
  Speed: <b id="spd">0</b> |
  Shield: <b id="shieldHud">0</b>
</div>
<div id="btnTop">
  <button id="pauseBtn" class="topBtn">Pause</button>
  <button id="openSettingsBtn" class="topBtn">Settings</button>
</div>
<div id="hint">Swipe L/R or use buttons • Swipe ↑ / Space to jump • Avoid red capsules • Collect crescent moons</div>

<div id="dockTab">Scores</div>
<aside id="leaderDock">
  <div id="playerNameDisplay"></div>
  <h3>Top Scores</h3>
  <ol id="leaderList"></ol>
  <div id="powerups">
    <div>Dash: <span id="dashT">0.0</span>s</div>
    <div>Magnet: <span id="magnetT">0.0</span>s</div>
  </div>
</aside>

<!-- Name -->
<div id="nameAsk" class="overlay">
  <div class="card" style="min-width:min(94vw,420px)">
    <h2 style="margin:0 0 8px">Enter Player Name</h2>
    <p class="note">Used for the leaderboard. You can change it later in Settings.</p>
    <input id="nameInput" type="text" placeholder="Your name" maxlength="24" style="width:100%; padding:10px; border-radius:10px; border:1px solid #374151; background:#0b1220; color:#e5e7eb; margin:8px 0 12px">
    <div class="row"><button id="nameSave">Save</button></div>
  </div>
</div>

<!-- Menu -->
<div id="menu" class="overlay" style="display:none">
  <div class="card">
    <h1 style="margin:0 0 6px">Runner 3D</h1>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="menuSettingsBtn" class="ghost">Settings</button>
    </div>
  </div>
</div>

<!-- Pause -->
<div id="pause" class="overlay">
  <div class="card">
    <h2 style="margin:0 0 8px">Paused</h2>
    <div class="row">
      <button id="resumeBtn">Resume</button>
      <button id="pauseSettingsBtn" class="ghost">Settings</button>
      <button id="restartBtn" class="ghost">Restart</button>
      <button id="toMenuBtn" class="ghost">Menu</button>
    </div>
  </div>
</div>

<!-- Settings -->
<div id="settings" class="overlay">
  <div class="card">
    <h2 style="margin:0 0 8px">Settings</h2>
    <div>
      <label>Player Name <input id="playerNameInp" type="text" maxlength="24" placeholder="Your name"></label>

      <label>Base Speed (u/s) <span><output id="baseOut">18.0</output></span></label>
      <input id="base" type="range" min="10.0" max="60.0" step="0.5" value="18.0">

      <label>Speed Ramp (u/s²) <span><output id="rampOut">1.70</output></span></label>
      <input id="ramp" type="range" min="0.00" max="3.00" step="0.05" value="1.70">

      <label>Max Speed (u/s) <span><output id="maxOut">40.0</output></span></label>
      <input id="max" type="range" min="20.0" max="60.0" step="0.5" value="40.0">

      <label>Gravity (u/s²) <span><output id="gravOut">-21</output></span></label>
      <input id="grav" type="range" min="-40" max="-5" step="1" value="-21">

      <label>Jump Strength (u/s) <span><output id="jumpOut">10.8</output></span></label>
      <input id="jump" type="range" min="6.0" max="20.0" step="0.1" value="10.8">

      <label>Spawn Density (spawns/sec) <span><output id="densOut">1.46</output></span></label>
      <input id="dens" type="range" min="0.00" max="2.50" step="0.02" value="1.46">

      <label>Grace Period (seconds) <span><output id="graceOut">1.7</output></span></label>
      <input id="grace" type="range" min="0.0" max="5.0" step="0.1" value="1.7">

      <label>Camera Follow (per s) <span><output id="camOut">6.0</output></span></label>
      <input id="cam" type="range" min="1.0" max="12.0" step="0.5" value="6.0">

      <label><span>Only collide when grounded</span><input id="colGround" type="checkbox"></label>
    </div>
    <p class="note">Most settings apply immediately. Grace re-applies on restart. Name saved to storage.</p>
    <div class="row">
      <button id="settingsSave">Save</button>
      <button id="settingsClose" class="ghost">Close</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameover" class="overlay">
  <div class="card">
    <h2>Game Over</h2>
    <p>Score: <span id="finalScore">0</span></p>
    <div class="row" style="margin-top:10px">
      <button id="goRestartBtn">Restart</button>
      <button id="goMenuBtn" class="ghost">Menu</button>
      <button id="goSettingsBtn" class="ghost">Settings</button>
    </div>
  </div>
</div>

<!-- Mobile Controls -->
<div id="mobileControls">
  <div class="mcBtn" id="btnLeft">⬅️</div>
  <div class="mcBtn" id="btnJump">⬆️</div>
  <div class="mcBtn" id="btnRight">➡️</div>
</div>

<canvas id="webgl"></canvas>

<script type="module">
/* CDN three.js (kept) */
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* -------- Safe storage wrapper (prevents GitHub/iOS Private crashes) -------- */
const storage = (() => {
  try {
    const k = '__probe__'; localStorage.setItem(k,'1'); localStorage.removeItem(k);
    return localStorage;
  } catch(e) {
    let mem = {};
    return {
      getItem:k => (k in mem ? mem[k] : null),
      setItem:(k,v)=>{ mem[k]=String(v) },
      removeItem:k=>{ delete mem[k] },
      clear:()=>{ mem={} }
    };
  }
})();

/* ---------- Keys ---------- */
const LB_KEY = 'runner_lb_v9';
const NAME_KEY = 'runner_name_v1';
const ST_KEY = 'runner_settings_v9';

/* ---------- Defaults (KEEPING YOUR TUNING) ---------- */
const DEFAULTS = {
  base: 18.0, ramp: 1.70, max: 40.0,
  gravity: -21, jump: 10.8,
  density: 1.46,
  grace: 1.7,
  camFollow: 6.0,
  collideGroundedOnly: false
};

/* ---------- Helpers ---------- */
const $ = id => document.getElementById(id);
const outBind = (inp, out, d=1) => inp.oninput = () => out.textContent = (+inp.value).toFixed(d);

/* ---------- Settings ---------- */
let settings = { ...DEFAULTS, ...(JSON.parse(storage.getItem(ST_KEY)||'{}')) };
function syncSettingsToUI() {
  base.value=settings.base; baseOut.textContent=settings.base.toFixed(1);
  ramp.value=settings.ramp; rampOut.textContent=settings.ramp.toFixed(2);
  max.value=settings.max;   maxOut.textContent=settings.max.toFixed(1);
  grav.value=settings.gravity; gravOut.textContent=settings.gravity.toFixed(0);
  jump.value=settings.jump; jumpOut.textContent=settings.jump.toFixed(1);
  dens.value=settings.density; densOut.textContent=settings.density.toFixed(2);
  grace.value=settings.grace; graceOut.textContent=settings.grace.toFixed(1);
  cam.value=settings.camFollow; camOut.textContent=settings.camFollow.toFixed(1);
  colGround.checked = !!settings.collideGroundedOnly;
  playerNameInp.value = storage.getItem(NAME_KEY)||'';
}
function saveSettingsFromUI() {
  settings.base=+base.value; settings.ramp=+ramp.value; settings.max=+max.value;
  settings.gravity=+grav.value; settings.jump=+jump.value; settings.density=+dens.value;
  settings.grace=+grace.value; settings.camFollow=+cam.value; settings.collideGroundedOnly=!!colGround.checked;
  storage.setItem(ST_KEY, JSON.stringify(settings));
  const newName = playerNameInp.value.trim();
  if (newName) storage.setItem(NAME_KEY, newName);
  refreshNameDisplay();
}
outBind(base,baseOut,1); outBind(ramp,rampOut,2); outBind(max,maxOut,1);
outBind(grav,gravOut,0); outBind(jump,jumpOut,1); outBind(dens,densOut,2);
outBind(grace,graceOut,1); outBind(cam,camOut,1);

/* ---------- Leaderboard (local for now) ---------- */
const leaderList = $('leaderList');
function getLB(){ return JSON.parse(storage.getItem(LB_KEY)||'[]'); }
function pushLB(name,score){ const lb=getLB(); lb.push({name,score,at:Date.now()}); lb.sort((a,b)=>b.score-a.score); storage.setItem(LB_KEY, JSON.stringify(lb.slice(0,5))); renderLB(); }
function renderLB(){
  const lb=getLB();
  leaderList.innerHTML = lb.slice(0,5).map(x=>`<li><span class="name">${(x.name||'Anon')}</span>: ${x.score}</li>`).join('');
}

/* ---------- Name ---------- */
function refreshNameDisplay(){
  const n = storage.getItem(NAME_KEY)||'';
  $('playerNameDisplay').textContent = n ? `Player: ${n}` : 'Player: (not set)';
}
(function ensureName(){
  const n = storage.getItem(NAME_KEY)||'';
  if (!n) { $('nameAsk').style.display='flex'; }
  else { $('menu').style.display='flex'; }
})();
$('nameSave').onclick = ()=>{
  const v = $('nameInput').value.trim(); if (!v) return;
  storage.setItem(NAME_KEY, v);
  $('nameAsk').style.display='none'; $('menu').style.display='flex'; refreshNameDisplay();
};
refreshNameDisplay(); renderLB();

/* ---------- Three.js ---------- */
const canvas = $('webgl');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: innerWidth > 768 });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0b0f14, 1);

const scene = new THREE.Scene(); // no fog (per your note)
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 400);
camera.position.set(0, 3.3, 7);

/* Night/space lights */
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(6, 10, 8); scene.add(dir);
const rim = new THREE.PointLight(0xff6666, 0.9, 120, 2.0); rim.position.set(0, 3, 6); scene.add(rim);

/* Floor */
const floor = new THREE.Mesh(new THREE.PlaneGeometry(280, 70), new THREE.MeshStandardMaterial({ color: 0x0f1420, roughness: 0.95, metalness:0.05 }));
floor.rotation.x = -Math.PI/2; scene.add(floor);

/* Player: sphere */
const R = 0.5;
const player = new THREE.Mesh(new THREE.SphereGeometry(R, 28, 18),
  new THREE.MeshStandardMaterial({ color: 0x3b82f6, metalness:.45, roughness:.35, emissive:0x0a1e44, emissiveIntensity:.35 }));
player.position.set(0, R, 0); scene.add(player);

/* Entities */
const obstacles=[], pickups=[], powerups=[];
const capGeo = new THREE.CapsuleGeometry(0.5, 1.0, 10, 16);
const capMat = new THREE.MeshStandardMaterial({ color: 0xff2e2e, emissive:0x390707, emissiveIntensity:1.0, metalness:.35, roughness:.25 });
function makeCapsule(){
  const root = new THREE.Group();
  const body = new THREE.Mesh(capGeo, capMat);
  const shell = new THREE.Mesh(capGeo, new THREE.MeshBasicMaterial({ color: 0x000000, wireframe:true, opacity:0.35, transparent:true }));
  shell.scale.set(1.08,1.08,1.08);
  root.add(body); root.add(shell);
  root.userData.body = body;
  return root;
}

/* Moons (white crescent) */
function makeCrescentSprite(size=0.9){
  const c = document.createElement('canvas'); c.width = c.height = 256;
  const g = c.getContext('2d');
  const grad = g.createRadialGradient(128,128,10,128,128,120);
  grad.addColorStop(0,'#ffffffee'); grad.addColorStop(0.4,'#ffffff66'); grad.addColorStop(1,'#0000');
  g.fillStyle = grad; g.beginPath(); g.arc(128,128,120,0,Math.PI*2); g.fill();
  g.globalCompositeOperation='source-over'; g.fillStyle='#fff';
  g.beginPath(); g.arc(128,128,70,0,Math.PI*2); g.fill();
  g.globalCompositeOperation='destination-out';
  g.beginPath(); g.arc(155,118,70,0,Math.PI*2); g.fill();
  const tex = new THREE.CanvasTexture(c); tex.transparent=true;
  const mat = new THREE.SpriteMaterial({ map:tex, depthWrite:false, transparent:true });
  const spr = new THREE.Sprite(mat); spr.scale.set(size, size, 1);
  spr.userData.isCrescent = true;
  return spr;
}

/* Power-ups (rarer, clearer) */
const shieldGeo = new THREE.TorusGeometry(0.52, 0.10, 18, 48);
const shieldMat = new THREE.MeshStandardMaterial({ color: 0x93c5fd, emissive:0x203a7a, emissiveIntensity:1.0, metalness:.55, roughness:.25 });
const dashGeo   = new THREE.ConeGeometry(0.36, 0.9, 24);
const dashMat   = new THREE.MeshStandardMaterial({ color: 0x9b5cf0, emissive:0x3a1766, emissiveIntensity:1.0, metalness:.45, roughness:.3 });
const magnetGeo = new THREE.TorusGeometry(0.55, 0.12, 20, 60, Math.PI);
const magnetMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive:0x4b2d00, emissiveIntensity:1.0, metalness:.5, roughness:.3 });

function makeGlowSprite(color='#ffd166'){
  const c = document.createElement('canvas'); c.width=c.height=256;
  const g = c.getContext('2d');
  const grad = g.createRadialGradient(128,128,20,128,128,120);
  grad.addColorStop(0,color); grad.addColorStop(0.6,color+'55'); grad.addColorStop(1,'#0000');
  g.fillStyle=grad; g.beginPath(); g.arc(128,128,120,0,Math.PI*2); g.fill();
  const t = new THREE.CanvasTexture(c); t.transparent=true;
  return new THREE.Sprite(new THREE.SpriteMaterial({ map:t, transparent:true, depthWrite:false }));
}
function makeTextSprite(txt='★', color='#fff'){
  const c = document.createElement('canvas'); c.width=256; c.height=128;
  const g = c.getContext('2d');
  g.font='64px system-ui,Segoe UI'; g.textAlign='center'; g.textBaseline='middle';
  g.fillStyle=color; g.shadowColor=color; g.shadowBlur=18; g.fillText(txt,128,64);
  const t = new THREE.CanvasTexture(c); t.transparent=true;
  const s = new THREE.Sprite(new THREE.SpriteMaterial({ map:t, transparent:true, depthWrite:false }));
  s.scale.set(1.0,0.5,1); return s;
}
function halo(text, color){
  const obj = new THREE.Group(); obj.className = 'labelHolder';
  const label = makeTextSprite(text, color); label.position.y = 0.9; obj.add(label);
  const glow = makeGlowSprite(color); glow.scale.set(1.6,1.6,1); obj.add(glow);
  return obj;
}

/* -------- Spawning (declumped + density-driven + infinite ramp) -------- */
let lastSpawnZ = -80;
const MIN_GAP = 10;      // hard min gap between lines
const LANE_X = [-2, 0, 2];

function spawnLine(z) {
  if (z - lastSpawnZ > -MIN_GAP) z = lastSpawnZ - MIN_GAP;
  lastSpawnZ = z;

  const lanes = LANE_X.slice();
  const t = Math.max(0, (performance.now() - startTime)/1000);

  // Difficulty scales forever
  const diff = 0.6 + t/35;   // grows unbounded (visually capped by min/max clamps below)

  // Choose 1–3 obstacles, biased by diff but never all 3 all the time
  const maxByDiff = Math.min(3, 1 + Math.floor(Math.min(2.4, diff)));
  const count = Math.min(lanes.length, 1 + (Math.random() < 0.55 ? 1 : 0) + (Math.random() < Math.min(0.2*diff, 0.5) ? 1 : 0));
  const finalCount = Math.min(maxByDiff, count);

  for (let i=0; i<finalCount; i++) {
    const lane = lanes.splice(Math.floor(Math.random()*lanes.length),1)[0];
    const o = makeCapsule();
    o.position.set(lane, 1.0, z);
    o.userData.phase = Math.random()*Math.PI*2;

    // More motion as diff grows
    if (Math.random() < Math.min(0.85, 0.55 + diff*0.15)) { o.userData.vxAmp = (0.7 + Math.random()*1.3) * Math.min(1.8, diff); o.userData.vxW = 0.8 + Math.random()*1.5; }
    if (Math.random() < Math.min(0.60, 0.30 + diff*0.12)) { o.userData.vyAmp = 0.10 + Math.random()*0.22; o.userData.vyW = 1.0 + Math.random()*1.2; }
    if (Math.random() < Math.min(0.45, 0.25 + diff*0.10)) { o.userData.swapTo = (Math.random()<0.5 ? -2 : 2); o.userData.swapSpeed = (0.35 + Math.random()*0.55) * Math.min(1.7, diff); }

    obstacles.push(o); scene.add(o);
  }

  // pickups/powerups
  if (lanes.length > 0) {
    const lane = lanes[Math.floor(Math.random()*lanes.length)];
    const roll = Math.random();
    if (roll < 0.78) {  // moons common
      const spr = makeCrescentSprite(1.0);
      spr.position.set(lane, 0.75, z - 3); pickups.push(spr); scene.add(spr);
    } else if (roll < 0.80) {  // ~2% shield
      const s = new THREE.Mesh(shieldGeo, shieldMat); s.rotation.x=Math.PI/2; s.position.set(lane,0.7,z-3); s.userData.type='shield';
      s.add(halo('🛡','#7cc0ff')); powerups.push(s); scene.add(s);
    } else if (roll < 0.82) {  // ~2% dash (works while airborne)
      const d = new THREE.Mesh(dashGeo, dashMat); d.position.set(lane,0.65,z-3); d.userData.type='dash';
      d.add(halo('⚡','#c9a7ff')); powerups.push(d); scene.add(d);
    } else if (roll < 0.84) {  // ~2% magnet
      const m = new THREE.Mesh(magnetGeo, magnetMat); m.rotation.z=Math.PI; m.position.set(lane,0.7,z-3); m.userData.type='magnet';
      m.add(halo('🧲','#ffd166')); powerups.push(m); scene.add(m);
    }
  }
}

/* ---------- UI / input ---------- */
const scoreEl=$('score'), timeEl=$('time'), spdEl=$('spd'), shieldHud=$('shieldHud');
const dashT=$('dashT'), magnetT=$('magnetT');

let lane=0, vy=0, speed=settings.base, score=0, running=false, paused=false;
let startTime=performance.now(), invulnUntil=0, spawnAcc=0;
let shield=0, dashUntil=0, magnetUntil=0;

const keys = new Set();
addEventListener('keydown', e => {
  if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','Escape'].includes(e.code)) e.preventDefault();
  keys.add(e.code);
  if (e.code === 'Escape' && running) setPaused(!paused);
}, {passive:false});
addEventListener('keyup', e => keys.delete(e.code), {passive:true});

$('btnLeft').onclick  = ()=> lane = Math.max(-2, lane-2);
$('btnRight').onclick = ()=> lane = Math.min(+2, lane+2);
$('btnJump').onclick  = ()=> { if (Math.abs(player.position.y-R) < 0.001) vy = settings.jump; };

let touchStartX=0, touchStartY=0;
addEventListener('touchstart', e => { touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; }, {passive:true});
addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 30) lane = Math.min(+2, lane+2);
    else if (dx < -30) lane = Math.max(-2, lane-2);
  } else if (dy < -30 && Math.abs(player.position.y-R) < 0.001) vy = settings.jump;
}, {passive:true});

/* Dock toggle (avoid overlap on phones) */
const dock = $('leaderDock'); const tab = $('dockTab');
tab.onclick = () => { dock.classList.toggle('open'); };

/* Buttons */
$('startBtn').onclick = startGame;
$('restartBtn').onclick = startGame;
$('goRestartBtn').onclick = startGame;
$('toMenuBtn').onclick = () => { setPaused(false); running=false; $('menu').style.display='flex'; };
$('goMenuBtn').onclick = () => { running=false; $('menu').style.display='flex'; $('gameover').style.display='none'; };
$('pauseBtn').onclick = () => { if (running) setPaused(!paused); };
$('resumeBtn').onclick = () => setPaused(false);
$('menuSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('pauseSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('openSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; setPaused(true); };
$('goSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('settingsSave').onclick = () => { saveSettingsFromUI(); $('settings').style.display='none'; };
$('settingsClose').onclick = () => { $('settings').style.display='none'; };

/* -------- Flow -------- */
function resetWorld(){
  for (const arr of [obstacles,pickups,powerups]) while (arr.length) scene.remove(arr.pop());
  lastSpawnZ = -90;
  for (let z=-50; z>=-160; z-=12) spawnLine(z);
  lane=0; vy=0; speed=settings.base; score=0; shield=0; shieldHud.textContent='0';
  dashUntil=0; magnetUntil=0; dashT.textContent='0.0'; magnetT.textContent='0.0';
  startTime = performance.now();
  invulnUntil = startTime + settings.grace*1000;
  spawnAcc = 0;
  player.position.set(0,R,0);
  scoreEl.textContent='0'; timeEl.textContent='0.0'; spdEl.textContent=settings.base.toFixed(2);
}
function startGame(){ $('menu').style.display='none'; $('gameover').style.display='none'; $('pause').style.display='none'; resetWorld(); running=true; paused=false; }
function endGame(){ running=false; paused=false; const name = storage.getItem(NAME_KEY)||'Anon'; $('finalScore').textContent = score; pushLB(name, score); renderLB(); $('gameover').style.display='flex'; }
function setPaused(p){ paused=p; $('pause').style.display = p ? 'flex' : 'none'; }

/* -------- Update / Render -------- */
function hitBallCapsule(ball, capGroup) {
  const cap = capGroup.userData.body || capGroup;
  const capR = 0.5, capHalf = 1.0;
  const dx = ball.x - capGroup.position.x;
  const dz = ball.z - capGroup.position.z;
  const touchXZ = Math.hypot(dx, dz) < (capR + R*0.98);
  const dy = Math.abs(ball.y - (capGroup.position.y));
  const touchY = dy < capHalf + R*0.65;
  return touchXZ && touchY;
}

function update(dt){
  if (!running || paused) return;
  const now = performance.now();

  // Inputs
  if ((keys.has('ArrowLeft')||keys.has('KeyA'))  && lane > -2) { lane -= 2; keys.delete('ArrowLeft'); keys.delete('KeyA'); }
  if ((keys.has('ArrowRight')||keys.has('KeyD')) && lane <  2) { lane += 2; keys.delete('ArrowRight'); keys.delete('KeyD'); }
  if ((keys.has('Space')||keys.has('ArrowUp')||keys.has('KeyW')) && Math.abs(player.position.y-R) < 0.001) {
    vy = settings.jump; keys.delete('Space'); keys.delete('ArrowUp'); keys.delete('KeyW');
  }

  // Smooth snap
  const kx = 1 - Math.exp(-12 * dt);
  player.position.x += (lane - player.position.x) * kx;

  // Vertical
  vy += settings.gravity * dt;
  player.position.y += vy * dt;
  if (player.position.y < R) { player.position.y = R; vy = 0; }

  // Obstacle motion
  for (const o of obstacles){
    const p = o.userData; const baseY=1.0;
    if (p.vxAmp) o.position.x += Math.sin(now/1000*p.vxW + p.phase) * p.vxAmp * dt;
    if (p.vyAmp) o.position.y = baseY + Math.sin(now/1000*p.vyW + p.phase) * p.vyAmp;
    if (p.swapTo !== undefined) {
      const toward = p.swapTo - o.position.x;
      o.position.x += Math.sign(toward) * Math.min(Math.abs(toward), p.swapSpeed * dt * 60) * 0.02;
    }
    o.position.x = Math.max(-2.6, Math.min(2.6, o.position.x));
  }

  // Power states (dash works mid-air; also grants brief immunity)
  const dashActive = now < dashUntil;
  const magnetActive = now < magnetUntil;
  dashT.textContent = Math.max(0, (dashUntil-now)/1000).toFixed(1);
  magnetT.textContent = Math.max(0, (magnetUntil-now)/1000).toFixed(1);

  const worldFactor = dashActive ? 1.25 : 1.0;
  obstacles.forEach(o => o.position.z += speed * worldFactor * dt);
  pickups.forEach(p   => { p.position.z += speed * worldFactor * dt; if (p.userData.isCrescent) p.material.rotation += 0.6*dt; });
  powerups.forEach(pu => pu.position.z += speed * worldFactor * dt);

  // Magnet attraction
  if (magnetActive){
    for (const p of pickups){
      const dx = player.position.x - p.position.x;
      const dy = player.position.y - p.position.y;
      const dz = (player.position.z - 1) - p.position.z;
      const dist = Math.hypot(dx,dy,dz);
      if (dist < 4){
        const pull = (4 - dist) * 2.2;
        p.position.x += (dx/(dist+1e-6)) * pull * dt;
        p.position.y += (dy/(dist+1e-6)) * pull * dt;
        p.position.z += (dz/(dist+1e-6)) * pull * dt;
      }
    }
  }

  // Cleanup
  for (let i=obstacles.length-1;i>=0;i--) if (obstacles[i].position.z > 12){ scene.remove(obstacles[i]); obstacles.splice(i,1); score+=5; }
  for (let i=pickups.length-1;i>=0;i--) if (pickups[i].position.z > 12){ scene.remove(pickups[i]); pickups.splice(i,1); }
  for (let i=powerups.length-1;i>=0;i--) if (powerups[i].position.z > 12){ scene.remove(powerups[i]); powerups.splice(i,1); }

  // Pacing: density-driven, declumped
  spawnAcc += dt * (1 + Math.min(2.0, ((now - startTime)/1000) / 30)); // scales with time
  let expected = settings.density * spawnAcc;
  while (expected >= 1) {
    spawnLine(-70 - Math.random()*30); // each line enforces MIN_GAP
    expected -= 1;
  }
  spawnAcc = expected;

  // Collisions — first hit kills unless shield (dash grants brief immunity)
  const grounded = player.position.y <= (R + 0.2);
  const canDie = now > invulnUntil && (!settings.collideGroundedOnly || grounded) && !dashActive;
  if (canDie){
    for (let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      if (hitBallCapsule(player.position, o)) {
        if (shield > 0){ shield--; shieldHud.textContent=String(shield); scene.remove(o); obstacles.splice(i,1); invulnUntil = now + 150; }
        else return endGame();
      }
    }
  }

  // Pickups
  for (let i=pickups.length-1;i>=0;i--){
    const p=pickups[i];
    const dx = player.position.x - p.position.x;
    const dy = player.position.y - p.position.y;
    const dz = player.position.z - p.position.z;
    if (Math.hypot(dx,dy,dz) < (R + 0.6)){ score+=20; scene.remove(p); pickups.splice(i,1); }
  }
  for (let i=powerups.length-1;i>=0;i--){
    const pu=powerups[i];
    const dx = player.position.x - pu.position.x;
    const dy = player.position.y - pu.position.y;
    const dz = player.position.z - pu.position.z;
    if (Math.hypot(dx,dy,dz) < (R + 0.7)){
      if (pu.userData.type==='shield'){ shield++; shieldHud.textContent=String(shield); }
      else if (pu.userData.type==='dash'){ dashUntil = now + 2500; invulnUntil = now + 300; } // mid-air ok
      else if (pu.userData.type==='magnet'){ magnetUntil = now + 5000; }
      scene.remove(pu); powerups.splice(i,1);
    }
  }

  // Speed ramp + HUD
  speed = Math.min(settings.max, speed + settings.ramp * dt);
  scoreEl.textContent = score;
  timeEl.textContent  = ((now - startTime)/1000).toFixed(1);
  spdEl.textContent   = speed.toFixed(2);
}

function render(dt){
  const k = 1 - Math.exp(-settings.camFollow * dt);
  const target = new THREE.Vector3(player.position.x*0.5, 3.3, 7);
  camera.position.lerp(target, k);
  camera.lookAt(player.position.x, 0.8, player.position.z - 2);
  renderer.render(scene, camera);
}

let last = performance.now();
function loop(now){ const dt = Math.min(0.05, (now - last)/1000); last = now; update(dt); render(dt); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

/* Resize */
addEventListener('resize', () => {
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
});
</script>
</body>
</html>


