<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Runner 3D — Mobile Ramp + Leaderboard</title>
<style>
html, body { height:100%; margin:0; background:#0b0f14; color:#e5e7eb; font:14px system-ui,Segoe UI,Roboto; overflow:hidden }
#hud { position:fixed; top:12px; left:12px; z-index:10; background:rgba(0,0,0,.35); padding:8px 12px; border-radius:10px; backdrop-filter: blur(6px); }
#hud b { font-weight:700; }
#hint { position:fixed; bottom:12px; left:12px; opacity:.8 }
#gameover, #menu { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.6); z-index:20 }
.card { background:#111827; padding:24px 28px; border-radius:16px; text-align:center; }
button { padding:10px 14px; border-radius:12px; border:0; background:#2563eb; color:white; font-weight:600; cursor:pointer; margin:4px }
#mobileControls { position:fixed; bottom:20px; width:100%; display:flex; justify-content:space-between; pointer-events:none; }
.mcBtn { background:rgba(0,0,0,0.4); padding:30px; border-radius:50%; pointer-events:auto; }
</style>
</head>
<body>

<div id="hud">Score: <b id="score">0</b> | Time: <b id="time">0.0</b>s | Speed: <b id="spd">0</b></div>
<div id="hint">Swipe or buttons to move/jump • Avoid red blocks • Collect green orbs</div>

<div id="menu">
  <div class="card">
    <h1>Runner 3D</h1>
    <p>Top Scores:</p>
    <ol id="leaderboard"></ol>
    <button id="startBtn">Start Game</button>
  </div>
</div>

<div id="gameover">
  <div class="card">
    <h2>Game Over</h2>
    <p>Score: <span id="finalScore">0</span></p>
    <p>Top Scores:</p>
    <ol id="leaderboardGO"></ol>
    <button id="restartBtn">Restart</button>
    <button id="menuBtn">Menu</button>
  </div>
</div>

<div id="mobileControls">
  <div class="mcBtn" id="btnLeft">⬅️</div>
  <div class="mcBtn" id="btnJump">⬆️</div>
  <div class="mcBtn" id="btnRight">➡️</div>
</div>

<canvas id="webgl"></canvas>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

const canvas = document.getElementById('webgl');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: innerWidth>768 });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0b0f14, 1);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 4, 8);
camera.lookAt(0, 0.5, 0);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.maxPolarAngle = Math.PI * 0.49;
if(innerWidth<768){controls.enabled=false;}

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(5, 8, 6);
scene.add(dir);

const floorGeo = new THREE.PlaneGeometry(100, 30);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 1 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

const playerGeo = new THREE.BoxGeometry(1,1,1);
const playerMat = new THREE.MeshStandardMaterial({ color: 0x3b82f6, metalness:.1, roughness:.6 });
const player = new THREE.Mesh(playerGeo, playerMat);
player.position.set(0, 0.5, 0);
scene.add(player);

const obstacles = [];
const pickups = [];
const oGeo = new THREE.BoxGeometry(1,1,1);
const oMat = new THREE.MeshStandardMaterial({ color: 0xef4444, roughness:.5 });
const pGeo = new THREE.SphereGeometry(0.35, 24, 16);
const pMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive:0x0a2, emissiveIntensity: .6 });

function spawnLine(z) {
  const lanes = [-2, 0, 2];
  const count = 1 + Math.floor(Math.random()*3);
  for (let i=0; i<count; i++) {
    const lane = lanes.splice(Math.floor(Math.random()*lanes.length),1)[0];
    const o = new THREE.Mesh(oGeo, oMat);
    o.position.set(lane, 0.5, z);
    obstacles.push(o);
    scene.add(o);
  }
  if (lanes.length > 0 && Math.random() < 0.8) {
    const lane = lanes[Math.floor(Math.random()*lanes.length)];
    const p = new THREE.Mesh(pGeo, pMat);
    p.position.set(lane, 0.5, z - 4);
    pickups.push(p);
    scene.add(p);
  }
}

function aabb(a, b, r=0.9) {
  return Math.abs(a.x - b.x) < r && Math.abs(a.y - b.y) < r && Math.abs(a.z - b.z) < r;
}

let lane=0, vy=0, g=-0.015, baseSpeed=0.08, ramp=0.0002, maxSpeed=0.25, curSpeed=baseSpeed;
let score=0, running=false, startTime=0;
const scoreEl=document.getElementById('score');
const timeEl=document.getElementById('time');
const spdEl=document.getElementById('spd');
const overUI=document.getElementById('gameover');
const finalScoreEl=document.getElementById('finalScore');
const leaderboardEl=document.getElementById('leaderboard');
const leaderboardGO=document.getElementById('leaderboardGO');

function loadLeaderboard(){
  return JSON.parse(localStorage.getItem('runnerLB')||'[]');
}
function saveLeaderboard(lb){
  localStorage.setItem('runnerLB',JSON.stringify(lb));
}
function updateLeaderboardUI(){
  const lb=loadLeaderboard();
  leaderboardEl.innerHTML=lb.map(s=>`<li>${s}</li>`).join('');
  leaderboardGO.innerHTML=lb.map(s=>`<li>${s}</li>`).join('');
}

function endGame(){
  running=false;
  overUI.style.display='flex';
  finalScoreEl.textContent=score;
  let lb=loadLeaderboard();
  lb.push(score);
  lb=lb.sort((a,b)=>b-a).slice(0,5);
  saveLeaderboard(lb);
  updateLeaderboardUI();
}

function startGame(){
  lane=0; vy=0; curSpeed=baseSpeed; score=0;
  startTime=performance.now();
  obstacles.forEach(o=>scene.remove(o));
  pickups.forEach(p=>scene.remove(p));
  obstacles.length=0; pickups.length=0;
  for (let z=4; z>=-50; z-=8) spawnLine(z);
  running=true;
}

document.getElementById('startBtn').onclick=()=>{
  document.getElementById('menu').style.display='none';
  startGame();
};
document.getElementById('restartBtn').onclick=()=>{
  overUI.style.display='none';
  startGame();
};
document.getElementById('menuBtn').onclick=()=>{
  overUI.style.display='none';
  document.getElementById('menu').style.display='flex';
};

updateLeaderboardUI();
document.getElementById('menu').style.display='flex';

// INPUT
const keys=new Set();
addEventListener('keydown',e=>keys.add(e.code));
addEventListener('keyup',e=>keys.delete(e.code));
document.getElementById('btnLeft').onclick=()=>lane=Math.max(lane-2,-2);
document.getElementById('btnRight').onclick=()=>lane=Math.min(lane+2,2);
document.getElementById('btnJump').onclick=()=>{if(Math.abs(player.position.y-0.5)<0.01)vy=0.28;};
let touchStartX=0,touchStartY=0;
addEventListener('touchstart',e=>{touchStartX=e.touches[0].clientX;touchStartY=e.touches[0].clientY;});
addEventListener('touchend',e=>{
  const dx=e.changedTouches[0].clientX-touchStartX;
  const dy=e.changedTouches[0].clientY-touchStartY;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>30) lane=Math.min(lane+2,2);
    else if(dx<-30) lane=Math.max(lane-2,-2);
  }else{
    if(dy<-30 && Math.abs(player.position.y-0.5)<0.01) vy=0.28;
  }
});

function update(dt){
  if ((keys.has('ArrowLeft')||keys.has('KeyA')) && lane>-2) lane-=2, keys.delete('ArrowLeft'),keys.delete('KeyA');
  if ((keys.has('ArrowRight')||keys.has('KeyD')) && lane<2) lane+=2, keys.delete('ArrowRight'),keys.delete('KeyD');
  if ((keys.has('Space')||keys.has('ArrowUp')||keys.has('KeyW')) && Math.abs(player.position.y-0.5)<0.01) vy=0.28;

  player.position.x += (lane - player.position.x) * 0.2;
  vy += g * dt;
  player.position.y += vy * dt;
  if (player.position.y < 0.5) { player.position.y = 0.5; vy = 0; }

  obstacles.forEach(o=>o.position.z += curSpeed * dt);
  pickups.forEach(p=>p.position.z += curSpeed * dt);

  for (let i=obstacles.length-1; i>=0; i--){
    if(obstacles[i].position.z>10){
      scene.remove(obstacles[i]); obstacles.splice(i,1); score+=5;
    }
  }
  for (let i=pickups.length-1; i>=0; i--){
    if(pickups[i].position.z>10){
      scene.remove(pickups[i]); pickups.splice(i,1);
    }
  }

  if(Math.random()<0.04) spawnLine(-50);

  for (const o of obstacles) if(aabb(player.position,o.position)) return endGame();
  for (let i=pickups.length-1; i>=0; i--){
    const p=pickups[i];
    if(aabb(player.position,p.position,0.8)){
      score+=20; scene.remove(p); pickups.splice(i,1);
    }
  }

  curSpeed = Math.min(curSpeed + ramp*dt, maxSpeed);

  scoreEl.textContent=score;
  timeEl.textContent=((performance.now()-startTime)/1000).toFixed(1);
  spdEl.textContent=curSpeed.toFixed(3);
}

function tick(){
  if(running){
    update(16.6);
    camera.position.lerp(new THREE.Vector3(player.position.x*0.5, 3.5, 7), 0.1);
    camera.lookAt(player.position.x, 0.8, player.position.z - 2);
  }
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();

addEventListener('resize',()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>