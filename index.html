<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Runner 3D — Ball + Moving Obstacles + Dash/Shield/Magnet</title>
<style>
  :root { --bg:#0b0f14; --fg:#e5e7eb; --panel:#111827; --glass:rgba(0,0,0,.55); --accent:#2563eb; --muted:#9ca3af; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font:14px system-ui,Segoe UI,Roboto; overflow:hidden }
  #hud { position:fixed; top:12px; left:12px; z-index:10; background:rgba(0,0,0,.35); padding:8px 12px; border-radius:10px; backdrop-filter: blur(6px); }
  #hud b { font-weight:700; }
  #btnTop { position:fixed; top:12px; right:260px; display:flex; gap:8px; z-index:12 }
  .topBtn { padding:8px 10px; border-radius:10px; border:0; background:#1f2937; color:#fff; font-weight:700 }
  #hint { position:fixed; bottom:12px; left:12px; opacity:.85 }
  .overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:var(--glass); z-index:20 }
  .card { background:var(--panel); padding:22px 26px; border-radius:16px; min-width:min(94vw,640px) }
  .row { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px }
  button { padding:10px 14px; border-radius:12px; border:0; background:var(--accent); color:white; font-weight:700; cursor:pointer }
  button.ghost { background:#1f2937 }
  label { display:flex; align-items:center; justify-content:space-between; gap:12px; margin:10px 0 }
  input[type="range"], input[type="text"] { width:260px }
  .note { color:var(--muted); font-size:12px }

  #mobileControls { position:fixed; bottom:20px; width:100%; display:flex; justify-content:space-between; pointer-events:none; z-index:12 }
  .mcBtn { background:rgba(0,0,0,0.45); padding:30px; border-radius:50%; pointer-events:auto; font-size:28px; color:white; user-select:none; }

  /* Leaderboard dock (always visible) */
  #leaderDock {
    position:fixed; top:0; right:0; width:240px; height:100%;
    background:rgba(0,0,0,.35); backdrop-filter: blur(6px);
    padding:12px; box-sizing:border-box; z-index:11;
    border-left:1px solid rgba(255,255,255,.06);
  }
  #leaderDock h3 { margin:6px 0 6px; font-size:16px }
  #leaderDock ol { margin:8px 0 0 18px }
  #leaderDock .name { color:#93c5fd }
  #powerups { margin-top:10px; font-size:12px; color:var(--muted) }
  #playerNameDisplay { font-size:12px; color:var(--muted); margin-bottom:6px }
</style>
</head>
<body>

<div id="hud">
  Score: <b id="score">0</b> |
  Time: <b id="time">0.0</b>s |
  Speed: <b id="spd">0</b> |
  Shield: <b id="shieldHud">0</b>
</div>
<div id="btnTop">
  <button id="pauseBtn" class="topBtn">Pause</button>
  <button id="openSettingsBtn" class="topBtn">Settings</button>
</div>
<div id="hint">Swipe L/R to change lanes, swipe ↑ to jump • Or use the big buttons • Avoid red capsules • Collect green orbs</div>

<!-- Always-on Leaderboard -->
<aside id="leaderDock">
  <div id="playerNameDisplay"></div>
  <h3>Top Scores</h3>
  <ol id="leaderList"></ol>
  <div id="powerups">
    <div>Dash: <span id="dashT">0.0</span>s</div>
    <div>Magnet: <span id="magnetT">0.0</span>s</div>
  </div>
</aside>

<!-- Name prompt -->
<div id="nameAsk" class="overlay">
  <div class="card" style="min-width:min(94vw,420px)">
    <h2 style="margin:0 0 8px">Enter Player Name</h2>
    <p class="note">Used for the leaderboard. You can change it later in Settings.</p>
    <input id="nameInput" type="text" placeholder="Your name" maxlength="24" style="width:100%; padding:10px; border-radius:10px; border:1px solid #374151; background:#0b1220; color:#e5e7eb; margin:8px 0 12px">
    <div class="row">
      <button id="nameSave">Save</button>
    </div>
  </div>
</div>

<!-- Menu -->
<div id="menu" class="overlay" style="display:none">
  <div class="card">
    <h1 style="margin:0 0 6px">Runner 3D</h1>
    <p class="note" style="margin:0 0 10px">Mobile-friendly, adjustable settings, local leaderboard.</p>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="menuSettingsBtn" class="ghost">Settings</button>
    </div>
  </div>
</div>

<!-- Pause -->
<div id="pause" class="overlay">
  <div class="card">
    <h2 style="margin:0 0 8px">Paused</h2>
    <div class="row">
      <button id="resumeBtn">Resume</button>
      <button id="pauseSettingsBtn" class="ghost">Settings</button>
      <button id="restartBtn" class="ghost">Restart</button>
      <button id="toMenuBtn" class="ghost">Menu</button>
    </div>
  </div>
</div>

<!-- Settings -->
<div id="settings" class="overlay">
  <div class="card">
    <h2 style="margin:0 0 8px">Settings</h2>
    <div>
      <label>Player Name <input id="playerNameInp" type="text" maxlength="24" placeholder="Your name"></label>

      <label>Base Speed (u/s) <span><output id="baseOut">12.0</output></span></label>
      <input id="base" type="range" min="10.0" max="60.0" step="0.5" value="12.0">

      <label>Speed Ramp (u/s²) <span><output id="rampOut">0.40</output></span></label>
      <input id="ramp" type="range" min="0.00" max="3.00" step="0.05" value="0.40">

      <label>Max Speed (u/s) <span><output id="maxOut">35.0</output></span></label>
      <input id="max" type="range" min="20.0" max="60.0" step="0.5" value="35.0">

      <label>Gravity (u/s²) <span><output id="gravOut">-18</output></span></label>
      <input id="grav" type="range" min="-40" max="-5" step="1" value="-18">

      <label>Jump Strength (u/s) <span><output id="jumpOut">10.8</output></span></label>
      <input id="jump" type="range" min="6.0" max="20.0" step="0.1" value="10.8">

      <label>Spawn Density (spawns/sec) <span><output id="densOut">0.30</output></span></label>
      <input id="dens" type="range" min="0.00" max="2.50" step="0.02" value="0.30">

      <label>Grace Period (seconds) <span><output id="graceOut">2.5</output></span></label>
      <input id="grace" type="range" min="0.0" max="5.0" step="0.1" value="2.5">

      <label>Camera Follow (per s) <span><output id="camOut">6.0</output></span></label>
      <input id="cam" type="range" min="1.0" max="12.0" step="0.5" value="6.0">

      <label><span>Only collide when grounded</span><input id="colGround" type="checkbox" checked></label>
    </div>
    <p class="note">Most settings apply immediately. Grace re-applies on restart. Name is saved to localStorage.</p>
    <div class="row">
      <button id="settingsSave">Save</button>
      <button id="settingsClose" class="ghost">Close</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameover" class="overlay">
  <div class="card">
    <h2>Game Over</h2>
    <p>Score: <span id="finalScore">0</span></p>
    <div class="row" style="margin-top:10px">
      <button id="goRestartBtn">Restart</button>
      <button id="goMenuBtn" class="ghost">Menu</button>
      <button id="goSettingsBtn" class="ghost">Settings</button>
    </div>
  </div>
</div>

<!-- Mobile Controls -->
<div id="mobileControls">
  <div class="mcBtn" id="btnLeft">⬅️</div>
  <div class="mcBtn" id="btnJump">⬆️</div>
  <div class="mcBtn" id="btnRight">➡️</div>
</div>

<canvas id="webgl"></canvas>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* --------- Storage & settings --------- */
const LB_KEY = 'runner_lb_v6';
const NAME_KEY = 'runner_name_v1';
const ST_KEY = 'runner_settings_v6';

const DEFAULTS = {
  base: 12.0, ramp: 0.40, max: 35.0,
  gravity: -18, jump: 10.8,
  density: 0.30,
  grace: 2.5,
  camFollow: 6.0,
  collideGroundedOnly: true
};

const $ = id => document.getElementById(id);
const outBind = (inp, out, d=1) => inp.oninput = () => out.textContent = (+inp.value).toFixed(d);

let settings = { ...DEFAULTS, ...(JSON.parse(localStorage.getItem(ST_KEY)||'{}')) };
function syncSettingsToUI() {
  base.value=settings.base; baseOut.textContent=settings.base.toFixed(1);
  ramp.value=settings.ramp; rampOut.textContent=settings.ramp.toFixed(2);
  max.value=settings.max;   maxOut.textContent=settings.max.toFixed(1);
  grav.value=settings.gravity; gravOut.textContent=settings.gravity.toFixed(0);
  jump.value=settings.jump; jumpOut.textContent=settings.jump.toFixed(1);
  dens.value=settings.density; densOut.textContent=settings.density.toFixed(2);
  grace.value=settings.grace; graceOut.textContent=settings.grace.toFixed(1);
  cam.value=settings.camFollow; camOut.textContent=settings.camFollow.toFixed(1);
  colGround.checked = !!settings.collideGroundedOnly;
  playerNameInp.value = localStorage.getItem(NAME_KEY)||'';
}
function saveSettingsFromUI() {
  settings.base=+base.value; settings.ramp=+ramp.value; settings.max=+max.value;
  settings.gravity=+grav.value; settings.jump=+jump.value; settings.density=+dens.value;
  settings.grace=+grace.value; settings.camFollow=+cam.value; settings.collideGroundedOnly=!!colGround.checked;
  localStorage.setItem(ST_KEY, JSON.stringify(settings));
  const newName = playerNameInp.value.trim();
  if (newName) localStorage.setItem(NAME_KEY, newName);
  refreshNameDisplay();
}
outBind(base,baseOut,1); outBind(ramp,rampOut,2); outBind(max,maxOut,1);
outBind(grav,gravOut,0); outBind(jump,jumpOut,1); outBind(dens,densOut,2);
outBind(grace,graceOut,1); outBind(cam,camOut,1);

/* --------- Leaderboard --------- */
const leaderList = $('leaderList');
function getLB(){ return JSON.parse(localStorage.getItem(LB_KEY)||'[]'); }
function pushLB(name,score){ const lb=getLB(); lb.push({name,score,at:Date.now()}); lb.sort((a,b)=>b.score-a.score); localStorage.setItem(LB_KEY, JSON.stringify(lb.slice(0,5))); renderLB(); }
function renderLB(){
  const lb=getLB();
  leaderList.innerHTML = lb.slice(0,5).map(x=>`<li><span class="name">${(x.name||'Anon')}</span>: ${x.score}</li>`).join('');
}

/* --------- Name handling --------- */
function refreshNameDisplay(){
  const n = localStorage.getItem(NAME_KEY)||'';
  $('playerNameDisplay').textContent = n ? `Player: ${n}` : 'Player: (not set)';
}
(function ensureName(){
  const n = localStorage.getItem(NAME_KEY)||'';
  if (!n) { $('nameAsk').style.display='flex'; }
  else { $('menu').style.display='flex'; }
})();
$('nameSave').onclick = ()=>{
  const v = $('nameInput').value.trim(); if (!v) return;
  localStorage.setItem(NAME_KEY, v);
  $('nameAsk').style.display='none'; $('menu').style.display='flex'; refreshNameDisplay();
};
refreshNameDisplay(); renderLB();

/* --------- Three.js --------- */
const canvas = $('webgl');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: innerWidth > 768 });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0b0f14, 1);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 3.3, 7);

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(5, 8, 6); scene.add(dir);

const floor = new THREE.Mesh(new THREE.PlaneGeometry(160, 36), new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 1 }));
floor.rotation.x = -Math.PI/2; scene.add(floor);

/* --------- Player: BALL --------- */
const R = 0.5;
const player = new THREE.Mesh(new THREE.SphereGeometry(R, 28, 18), new THREE.MeshStandardMaterial({ color: 0x3b82f6, metalness:.2, roughness:.45 }));
player.position.set(0, R, 0); scene.add(player);

/* --------- Entities & materials --------- */
const obstacles=[], pickups=[], powerups=[];
const capGeo = new THREE.CapsuleGeometry(0.5, 0.9, 6, 12); // nicer obstacle
const capMat = new THREE.MeshStandardMaterial({ color: 0xef4444, emissive:0x220000, emissiveIntensity:.5, roughness:.45 });

const orbGeo = new THREE.SphereGeometry(0.35, 24, 16);
const orbMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive:0x0a2, emissiveIntensity: .65 });

const shieldGeo = new THREE.TorusGeometry(0.5, 0.12, 16, 40); // halo
const shieldMat = new THREE.MeshStandardMaterial({ color: 0x93c5fd, emissive:0x1a2a5f, emissiveIntensity:.9, metalness:.3, roughness:.35 });

const dashGeo = new THREE.ConeGeometry(0.42, 0.9, 16);          // arrow head
const dashMat = new THREE.MeshStandardMaterial({ color: 0xa855f7, emissive:0x3a1766, emissiveIntensity:.9 });

const magnetGeo = new THREE.TorusGeometry(0.55, 0.12, 14, 50, Math.PI); // horseshoe arc
const magnetMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive:0x4b2d00, emissiveIntensity:.8 });

/* --------- Spawning --------- */
let lastSpawnZ = -28;
function spawnLine(z) {
  if (z - lastSpawnZ > -8) z = lastSpawnZ - 8;
  lastSpawnZ = z;

  const lanes = [-2, 0, 2];

  // 80% moving, 30% lane-swap, 50% bobbing
  const moving = Math.random() < 0.8;
  const laneSwap = Math.random() < 0.3;
  const bobbing = Math.random() < 0.5;

  const count = 1 + Math.floor(Math.random()*2); // 1..2 obstacles
  for (let i=0; i<count; i++) {
    const lane = lanes.splice(Math.floor(Math.random()*lanes.length),1)[0];
    const o = new THREE.Mesh(capGeo, capMat);
    o.position.set(lane, 0.95, z);

    o.userData.phase = Math.random()*Math.PI*2;
    if (moving) {
      o.userData.vxAmp = 0.8 + Math.random()*1.0;  // more lateral sway
      o.userData.vxW   = 1.0 + Math.random()*1.6;  // speed
    }
    if (bobbing) {
      o.userData.vyAmp = 0.12 + Math.random()*0.18;
      o.userData.vyW   = 1.0 + Math.random()*1.4;
    }
    if (laneSwap) {
      o.userData.swapTo = (Math.random()<0.5 ? -2 : 2); // drift toward edge lane
      o.userData.swapSpeed = 0.3 + Math.random()*0.5;
    }

    obstacles.push(o); scene.add(o);
  }

  // reward/powerups
  if (lanes.length > 0) {
    const lane = lanes[Math.floor(Math.random()*lanes.length)];
    const roll = Math.random();
    if (roll < 0.55) {
      const p = new THREE.Mesh(orbGeo, orbMat);
      p.position.set(lane, 0.5, z - 3); pickups.push(p); scene.add(p);
    } else if (roll < 0.75) {
      const s = new THREE.Mesh(shieldGeo, shieldMat);
      s.rotation.x = Math.PI/2;
      s.position.set(lane, 0.6, z - 3); s.userData.type='shield'; powerups.push(s); scene.add(s);
    } else if (roll < 0.90) {
      const s = new THREE.Mesh(dashGeo, dashMat);   // DASH
      s.position.set(lane, 0.6, z - 3); s.userData.type='dash'; powerups.push(s); scene.add(s);
    } else {
      const m = new THREE.Mesh(magnetGeo, magnetMat);
      m.rotation.z = Math.PI; // open side down
      m.position.set(lane, 0.65, z - 3); m.userData.type='magnet'; powerups.push(m); scene.add(m);
    }
  }
}

/* --------- Helpers --------- */
const scoreEl=$('score'), timeEl=$('time'), spdEl=$('spd'), shieldHud=$('shieldHud');
const dashT=$('dashT'), magnetT=$('magnetT');
const EPS=1e-6;

/* Tight collision: ball (radius R) vs capsule approx
   We check XZ distance vs capsule radius, and Y difference vs capsule half-height.
*/
function hitBallCapsule(ball, cap) {
  const capR = 0.5;              // capsule radius
  const capHalf = 0.9*0.5 + 0.5; // roughly half-height (cylinder + hemis)
  const dx = ball.x - cap.x, dz = ball.z - cap.z;
  const distXZ = Math.hypot(dx, dz);
  const touchXZ = distXZ < (capR + R * 0.95);
  const dy = Math.abs(ball.y - cap.y);
  const touchY = dy < capHalf + R*0.6;
  return touchXZ && touchY;
}

/* --------- Game state --------- */
let lane=0, vy=0, speed=settings.base, score=0, running=false, paused=false;
let startTime=0, invulnUntil=0, spawnAcc=0;
let shield=0, dashUntil=0, magnetUntil=0;

/* --------- Input --------- */
const keys = new Set();
addEventListener('keydown', e => {
  if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','Escape'].includes(e.code)) e.preventDefault();
  keys.add(e.code);
  if (e.code === 'Escape' && running) setPaused(!paused);
}, {passive:false});
addEventListener('keyup', e => keys.delete(e.code), {passive:true});

$('btnLeft').onclick  = ()=> lane = Math.max(-2, lane-2);
$('btnRight').onclick = ()=> lane = Math.min(+2, lane+2);
$('btnJump').onclick  = ()=> { if (Math.abs(player.position.y-R) < 0.001) vy = settings.jump; };

let touchStartX=0, touchStartY=0;
addEventListener('touchstart', e => { touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; }, {passive:true});
addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 30) lane = Math.min(+2, lane+2);
    else if (dx < -30) lane = Math.max(-2, lane-2);
  } else if (dy < -30 && Math.abs(player.position.y-R) < 0.001) {
    vy = settings.jump;
  }
}, {passive:true});

/* --------- Buttons --------- */
$('startBtn').onclick = startGame;
$('restartBtn').onclick = startGame;
$('goRestartBtn').onclick = startGame;
$('toMenuBtn').onclick = () => { setPaused(false); running=false; $('menu').style.display='flex'; };
$('goMenuBtn').onclick = () => { running=false; $('menu').style.display='flex'; $('gameover').style.display='none'; };
$('pauseBtn').onclick = () => { if (running) setPaused(!paused); };
$('resumeBtn').onclick = () => setPaused(false);

$('menuSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('pauseSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('openSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; setPaused(true); };
$('goSettingsBtn').onclick = () => { syncSettingsToUI(); $('settings').style.display='flex'; };
$('settingsSave').onclick = () => { saveSettingsFromUI(); $('settings').style.display='none'; };
$('settingsClose').onclick = () => { $('settings').style.display='none'; };

/* --------- Flow --------- */
function resetWorld(){
  for (const arr of [obstacles,pickups,powerups]) while (arr.length) scene.remove(arr.pop());
  lastSpawnZ = -28;
  [-16,-24,-32,-40,-48].forEach(z=>spawnLine(z));
  lane=0; vy=0; speed=settings.base; score=0; shield=0; shieldHud.textContent='0';
  dashUntil=0; magnetUntil=0; dashT.textContent='0.0'; magnetT.textContent='0.0';
  startTime = performance.now();
  invulnUntil = startTime + settings.grace*1000;
  spawnAcc = 0;
  player.position.set(0,R,0);
  scoreEl.textContent='0'; timeEl.textContent='0.0'; spdEl.textContent=settings.base.toFixed(2);
}
function startGame(){
  $('menu').style.display='none'; $('gameover').style.display='none'; $('pause').style.display='none';
  resetWorld(); running=true; paused=false;
}
function endGame(){
  running=false; paused=false;
  const name = localStorage.getItem(NAME_KEY)||'Anon';
  $('finalScore').textContent = score;
  pushLB(name, score);
  renderLB();
  $('gameover').style.display='flex';
}
function setPaused(p){ paused=p; $('pause').style.display = p ? 'flex' : 'none'; }

/* --------- Update / Render --------- */
function update(dt){
  if (!running || paused) return;
  const now = performance.now();

  // inputs
  if ((keys.has('ArrowLeft')||keys.has('KeyA'))  && lane > -2) { lane -= 2; keys.delete('ArrowLeft'); keys.delete('KeyA'); }
  if ((keys.has('ArrowRight')||keys.has('KeyD')) && lane <  2) { lane += 2; keys.delete('ArrowRight'); keys.delete('KeyD'); }
  if ((keys.has('Space')||keys.has('ArrowUp')||keys.has('KeyW')) && Math.abs(player.position.y-R) < 0.001) {
    vy = settings.jump; keys.delete('Space'); keys.delete('ArrowUp'); keys.delete('KeyW');
  }

  // smooth lane snap
  const kx = 1 - Math.exp(-12 * dt);
  player.position.x += (lane - player.position.x) * kx;

  // vertical motion
  vy += settings.gravity * dt;
  player.position.y += vy * dt;
  if (player.position.y < R) { player.position.y = R; vy = 0; }

  // obstacle motion (wiggle + bob + optional lane drift)
  for (const o of obstacles){
    const p = o.userData;
    const baseY = 0.95;
    if (p.vxAmp) o.position.x += Math.sin(now/1000*p.vxW + p.phase) * p.vxAmp * dt;
    if (p.vyAmp) o.position.y = baseY + Math.sin(now/1000*p.vyW + p.phase) * p.vyAmp;
    if (p.swapTo !== undefined) {
      const toward = p.swapTo - o.position.x;
      o.position.x += Math.sign(toward) * Math.min(Math.abs(toward), p.swapSpeed * dt * 60) * 0.02;
    }
    o.position.x = Math.max(-2.6, Math.min(2.6, o.position.x));
  }

  // power-up timers
  const dashActive = now < dashUntil;
  const magnetActive = now < magnetUntil;
  dashT.textContent = Math.max(0, (dashUntil-now)/1000).toFixed(1);
  magnetT.textContent = Math.max(0, (magnetUntil-now)/1000).toFixed(1);

  // world forward
  const worldFactor = dashActive ? 1.5 : 1.0;
  obstacles.forEach(o => o.position.z += speed * worldFactor * dt);
  pickups.forEach(p   => p.position.z += speed * worldFactor * dt);
  powerups.forEach(pu => pu.position.z += speed * worldFactor * dt);

  // magnet attraction
  if (magnetActive){
    for (const p of pickups){
      const dx = player.position.x - p.position.x;
      const dy = player.position.y - p.position.y;
      const dz = (player.position.z - 1) - p.position.z;
      const dist = Math.hypot(dx,dy,dz);
      if (dist < 4){
        const pull = (4 - dist) * 2.5;
        p.position.x += (dx/(dist+EPS)) * pull * dt;
        p.position.y += (dy/(dist+EPS)) * pull * dt;
        p.position.z += (dz/(dist+EPS)) * pull * dt;
      }
    }
  }

  // cleanup
  const clean = arr => { for (let i=arr.length-1;i>=0;i--) if (arr[i].position.z > 10) { scene.remove(arr[i]); arr.splice(i,1); } };
  for (let i=obstacles.length-1;i>=0;i--) if (obstacles[i].position.z > 10){ scene.remove(obstacles[i]); obstacles.splice(i,1); score+=5; }
  clean(pickups); clean(powerups);

  // spawn pacing with scaling difficulty
  spawnAcc += dt * (1 + Math.min(1.2, ((now - startTime)/1000) / 50));
  const expected = settings.density * spawnAcc;
  if (expected >= 1) {
    for (let i=0; i<Math.floor(expected); i++) spawnLine(-36 - Math.random()*12);
    spawnAcc = expected - Math.floor(expected);
  }

  // collisions — grounded-only optional; no ghosting; dash grants invuln
  const grounded = player.position.y <= (R + 0.2);
  const canDie = now > invulnUntil && (!settings.collideGroundedOnly || grounded) && !dashActive;

  if (canDie){
    for (let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      if (hitBallCapsule(player.position, o.position)) {
        if (shield > 0){
          shield--; shieldHud.textContent=String(shield);
          scene.remove(o); obstacles.splice(i,1);
          invulnUntil = now + 300; // very short post-hit buffer only for shield pop
        } else {
          return endGame();
        }
      }
    }
  }

  // pickups
  for (let i=pickups.length-1;i>=0;i--){
    const p=pickups[i];
    const dx = player.position.x - p.position.x;
    const dy = player.position.y - p.position.y;
    const dz = player.position.z - p.position.z;
    if (Math.hypot(dx,dy,dz) < (R + 0.6)){ score+=20; scene.remove(p); pickups.splice(i,1); }
  }
  for (let i=powerups.length-1;i>=0;i--){
    const pu=powerups[i];
    const dx = player.position.x - pu.position.x;
    const dy = player.position.y - pu.position.y;
    const dz = player.position.z - pu.position.z;
    if (Math.hypot(dx,dy,dz) < (R + 0.7)){
      if (pu.userData.type==='shield'){ shield++; shieldHud.textContent=String(shield); }
      else if (pu.userData.type==='dash'){ dashUntil = now + 3500; }
      else if (pu.userData.type==='magnet'){ magnetUntil = now + 6000; }
      scene.remove(pu); powerups.splice(i,1);
    }
  }

  // ramp speed
  speed = Math.min(settings.max, speed + settings.ramp * dt);

  // HUD
  scoreEl.textContent = score;
  timeEl.textContent  = ((now - startTime)/1000).toFixed(1);
  spdEl.textContent   = speed.toFixed(2);
}

function render(dt){
  const k = 1 - Math.exp(-settings.camFollow * dt);
  const target = new THREE.Vector3(player.position.x*0.5, 3.3, 7);
  camera.position.lerp(target, k);
  camera.lookAt(player.position.x, 0.8, player.position.z - 2);
  renderer.render(scene, camera);
}

let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000); last = now;
  update(dt); render(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* --------- Resize --------- */
addEventListener('resize', () => {
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
});
</script>
</body>
</html>
