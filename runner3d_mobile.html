<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>Runner 3D — Mobile</title>
  <style>
    :root { --bg:#0b0f14; --fg:#e5e7eb; --panel:#0f172a; --glass:rgba(0,0,0,.55); --accent:#2563eb; --muted:#9ca3af; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font:15px system-ui,Segoe UI,Roboto; touch-action:none; }
    button { padding:14px 18px; border-radius:14px; border:0; background:var(--accent); color:white; font-weight:800; cursor:pointer; touch-action:manipulation }
    button.ghost { background:#1f2937 }
    label { display:flex; align-items:center; justify-content:space-between; gap:12px; margin:12px 0 }
    input[type="range"] { width:260px }
    .overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:var(--glass); z-index:50; backdrop-filter: blur(4px) }
    .card { background:var(--panel); padding:26px 30px; border-radius:18px; min-width: min(94vw, 620px); box-shadow: 0 10px 30px rgba(0,0,0,.4) }
    .row { display:flex; gap:12px; flex-wrap:wrap }
    #hud { position:fixed; top:10px; left:10px; z-index:10; background:rgba(0,0,0,.35); padding:10px 14px; border-radius:12px; backdrop-filter: blur(6px); }
    #hud b { font-weight:800 }
    #hint { position:fixed; bottom:12px; left:12px; opacity:.9; z-index:10 }
    #pause { position:fixed; top:10px; right:10px; z-index:10 }
    #touch { position:fixed; bottom:12px; right:12px; display:flex; gap:12px; z-index:12 }
    #touch button { padding:18px 22px; border-radius:18px; font-size:20px }
    @media (max-width: 860px) {
      #hint { display:none }
    }
  </style>
  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
</head>
<body>
  <div id="hud">Score: <b id="score">0</b> &nbsp; | &nbsp; Time: <b id="time">0.0</b>s &nbsp; | &nbsp; Shield: <b id="shieldHud">0</b></div>
  <div id="hint">WASD/Arrows move • Space jump • Esc pause • Swipe L/R to lane, swipe up to jump</div>
  <div id="pause"><button id="pauseBtn" class="ghost">Pause</button></div>

  <!-- On-screen mobile controls -->
  <div id="touch">
    <button id="btnLeft" class="ghost">⟵</button>
    <button id="btnJump">⤒</button>
    <button id="btnRight" class="ghost">⟶</button>
  </div>

  <div id="menu" class="overlay" style="display:flex">
    <div class="card">
      <h1>Runner 3D — Mobile</h1>
      <p style="color:var(--muted);margin:0 0 14px">Swipe or use on-screen buttons. Tip: rotate phone to landscape.</p>
      <div class="row">
        <button id="startBtn">Start</button>
        <button id="settingsBtn" class="ghost">Settings</button>
      </div>
    </div>
  </div>

  <div id="settings" class="overlay">
    <div class="card">
      <h2 style="margin:0 0 8px">Settings</h2>
      <div>
        <label>Game Speed (u/s) <span><output id="speedOut">2.0</output></span></label>
        <input id="speed" type="range" min="0.8" max="4.0" step="0.1" value="2.0">
        <label>Spawn Density <span><output id="densityOut">0.008</output></span></label>
        <input id="density" type="range" min="0.000" max="0.040" step="0.002" value="0.008">
        <label>Camera Follow (per s) <span><output id="camOut">3.0</output></span></label>
        <input id="cam" type="range" min="0.5" max="6.0" step="0.1" value="3.0">
        <label>Jump Strength <span><output id="jumpOut">10.5</output></span></label>
        <input id="jump" type="range" min="7.0" max="14.0" step="0.1" value="10.5">
        <label>Gravity <span><output id="gravOut">-18</output></span></label>
        <input id="grav" type="range" min="-26" max="-10" step="1" value="-18">
      </div>
      <div class="row" style="margin-top:14px">
        <button id="settingsSave">Save</button>
        <button id="settingsCancel" class="ghost">Back</button>
        <button id="settingsMenu" class="ghost">Return to Menu</button>
      </div>
    </div>
  </div>

  <div id="pauseOverlay" class="overlay">
    <div class="card">
      <h2 style="margin:0 0 8px">Paused</h2>
      <div class="row">
        <button id="resumeBtn">Resume</button>
        <button id="pauseSettingsBtn" class="ghost">Settings</button>
        <button id="pauseRestartBtn" class="ghost">Restart</button>
        <button id="pauseMenuBtn" class="ghost">Return to Menu</button>
      </div>
    </div>
  </div>

  <div id="gameover" class="overlay">
    <div class="card">
      <h2>Game Over</h2>
      <p style="margin:0 0 16px">Score: <span id="finalScore">0</span></p>
      <div class="row">
        <button id="restartBtn">Restart</button>
        <button id="goMenuBtn" class="ghost">Return to Menu</button>
        <button id="goSettingsBtn" class="ghost">Settings</button>
      </div>
    </div>
  </div>

  <canvas id="webgl"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ---------- Settings ----------
    const settings = { speed: 2.0, density: 0.008, camFollow: 3.0, jump: 10.5, gravity: -18 };
    const el = (id)=>document.getElementById(id);
    const menu = el('menu'), settingsOv = el('settings'), pauseOv = el('pauseOverlay'), goOv = el('gameover');
    const speedIn = el('speed'), densityIn = el('density'), camIn = el('cam'), jumpIn = el('jump'), gravIn = el('grav');
    const speedOut = el('speedOut'), densityOut = el('densityOut'), camOut = el('camOut'), jumpOut = el('jumpOut'), gravOut = el('gravOut');
    const scoreEl = el('score'), timeEl = el('time'), finalScoreEl = el('finalScore'), shieldHud = el('shieldHud');

    const setSettingsUI = () => {
      speedIn.value = settings.speed.toFixed(1);
      densityIn.value = settings.density.toFixed(3);
      camIn.value = settings.camFollow.toFixed(1);
      jumpIn.value = settings.jump.toFixed(1);
      gravIn.value = settings.gravity.toFixed(0);
      speedOut.textContent = Number(speedIn.value).toFixed(1);
      densityOut.textContent = Number(densityIn.value).toFixed(3);
      camOut.textContent = Number(camIn.value).toFixed(1);
      jumpOut.textContent = Number(jumpIn.value).toFixed(1);
      gravOut.textContent = Number(gravIn.value).toFixed(0);
    };
    setSettingsUI();
    for (const [inp,out,fmt] of [[speedIn,speedOut,1],[densityIn,densityOut,3],[camIn,camOut,1],[jumpIn,jumpOut,1],[gravIn,gravOut,0]]) {
      inp.oninput = ()=> out.textContent = Number(inp.value).toFixed(fmt);
    }
    el('settingsBtn').onclick = ()=> { setSettingsUI(); settingsOv.style.display='flex'; };
    el('pauseSettingsBtn').onclick = ()=> { setSettingsUI(); pauseOv.style.display='none'; settingsOv.style.display='flex'; };
    el('settingsCancel').onclick = ()=> { settingsOv.style.display='none'; };
    el('settingsSave').onclick = ()=> {
      settings.speed = Number(speedIn.value);
      settings.density = Number(densityIn.value);
      settings.camFollow = Number(camIn.value);
      settings.jump = Number(jumpIn.value);
      settings.gravity = Number(gravIn.value);
      settingsOv.style.display='none';
    };
    el('settingsMenu').onclick = ()=> { settingsOv.style.display='none'; toMenu(); };

    // ---------- Three basics (mobile perf tweaks) ----------
    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const canvas = document.getElementById('webgl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: !isMobile }); // drop AA on mobile if needed
    const DPR_CAP = isMobile ? 1.5 : 2;
    renderer.setPixelRatio(Math.min(devicePixelRatio, DPR_CAP));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x0b0f14, 1);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 3.5, 7); camera.lookAt(0, 0.5, 0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.enablePan = false; controls.maxPolarAngle = Math.PI * 0.49;
    if (isMobile) { controls.enabled = false; } // prevent accidental camera drags on phones

    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5, 8, 6); scene.add(dir);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(120, 36), new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 1 }));
    floor.rotation.x = -Math.PI/2; floor.position.z = 0; scene.add(floor);

    const player = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color: 0x3b82f6, metalness:.1, roughness:.6 }));
    player.position.set(0, 0.5, 0); scene.add(player);

    // Entities
    const obstacles = [], pickups = [], shields = [];
    const oMat = new THREE.MeshStandardMaterial({ color: 0xef4444, roughness:.5 });
    const pMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive:0x0a2, emissiveIntensity: .7 });
    const sMat = new THREE.MeshStandardMaterial({ color: 0x60a5fa, emissive:0x124, emissiveIntensity:.8, metalness:.3, roughness:.4 });
    let lastSpawnZ = -28;

    function spawnLine(z) {
      if (z - lastSpawnZ > -6) z = lastSpawnZ - 6;
      lastSpawnZ = z;
      const lanes = [-2, 0, 2];
      const count = 1 + Math.floor(Math.random()*2);
      for (let i=0; i<count; i++) {
        const lane = lanes.splice(Math.floor(Math.random()*lanes.length),1)[0];
        const o = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), oMat);
        o.position.set(lane, 0.5, z); obstacles.push(o); scene.add(o);
      }
      if (lanes.length > 0) {
        const lane = lanes[Math.floor(Math.random()*lanes.length)];
        const roll = Math.random();
        if (roll < 0.65) { const p = new THREE.Mesh(new THREE.SphereGeometry(0.35,20,14), pMat); p.position.set(lane, 0.5, z - 3); pickups.push(p); scene.add(p); }
        else if (roll < 0.9) { const s = new THREE.Mesh(new THREE.IcosahedronGeometry(0.4,0), sMat); s.position.set(lane, 0.6, z - 3); shields.push(s); scene.add(s); }
      }
    }

    function resetWorld() {
      for (const arr of [obstacles, pickups, shields]) while (arr.length) scene.remove(arr.pop());
      [24, 18, 12, -12, -20, -28, -36, -44].forEach(z=>spawnLine(z));
      player.position.set(0,0.5,0);
      lane = 0; vy = 0;
      invulnUntil = performance.now() + 2000;
      jumpBufferedUntil = 0; lastGroundedAt = performance.now();
      score = 0; startTime = performance.now(); shield = 0; shieldHud.textContent = '0';
      scoreEl.textContent = '0'; timeEl.textContent = '0.0';
    }

    // Input (keys + touch + swipe)
    const keys = new Set();
    const prevent = new Set(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','PageUp','PageDown']);
    addEventListener('keydown', e => { if (prevent.has(e.code)) e.preventDefault(); keys.add(e.code); if (e.code === 'Escape') togglePause(); }, { passive:false });
    addEventListener('keyup',   e => { if (prevent.has(e.code)) e.preventDefault(); keys.delete(e.code); }, { passive:false });

    // On-screen buttons
    el('btnLeft').addEventListener('pointerdown', ()=> keys.add('ArrowLeft'));
    el('btnLeft').addEventListener('pointerup',   ()=> keys.delete('ArrowLeft'));
    el('btnRight').addEventListener('pointerdown',()=> keys.add('ArrowRight'));
    el('btnRight').addEventListener('pointerup',  ()=> keys.delete('ArrowRight'));
    el('btnJump').addEventListener('pointerdown', ()=> { keys.add('Space'); jumpBufferedUntil = performance.now() + 160; });
    el('btnJump').addEventListener('pointerup',   ()=> keys.delete('Space'));

    // Swipe gestures on the canvas
    let touchStartX=0, touchStartY=0, touchTime=0;
    const SWIPE_DIST = 35;  // px
    const SWIPE_TIME = 400; // ms
    canvas.addEventListener('pointerdown', (e)=>{
      if (e.pointerType !== 'mouse') {
        touchStartX = e.clientX; touchStartY = e.clientY; touchTime = performance.now();
      }
    });
    canvas.addEventListener('pointerup', (e)=>{
      if (e.pointerType !== 'mouse') {
        const dx = e.clientX - touchStartX;
        const dy = e.clientY - touchStartY;
        const dt = performance.now() - touchTime;
        if (dt <= SWIPE_TIME) {
          if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > SWIPE_DIST) {
            if (dx < 0) keys.add('ArrowLeft'); else keys.add('ArrowRight');
            setTimeout(()=>{ keys.delete('ArrowLeft'); keys.delete('ArrowRight'); }, 1);
          } else if (dy < -SWIPE_DIST) {
            keys.add('Space'); jumpBufferedUntil = performance.now() + 160;
            setTimeout(()=> keys.delete('Space'), 1);
          }
        }
      }
    });

    // Fullscreen + orientation hint on Start (best-effort)
    async function goFullscreen() {
      try { await canvas.requestFullscreen(); } catch {}
      try { if (screen.orientation && screen.orientation.lock) await screen.orientation.lock('landscape'); } catch {}
    }

    // State / physics
    let lane = 0, vy = 0;
    let running = false, score = 0, shield = 0, invulnUntil = 0, startTime = performance.now(), lastSpawnT = 0;
    const COYOTE_MS = 140, JUMP_BUFFER_MS = 160;
    let lastGroundedAt = performance.now(), jumpBufferedUntil = 0;
    const g = ()=> settings.gravity;
    function grounded() { return player.position.y <= 0.505; }
    function tryJump(now) {
      const canCoyote = now - lastGroundedAt <= COYOTE_MS;
      const buffered = now <= jumpBufferedUntil;
      const allow = grounded() || canCoyote || buffered;
      if (allow) { vy = settings.jump; jumpBufferedUntil = 0; }
    }

    function update(dt) {
      if (!running) return;
      const now = performance.now();

      if ((keys.has('ArrowLeft') || keys.has('KeyA')) && lane > -2) { lane -= 2; keys.delete('ArrowLeft'); keys.delete('KeyA'); }
      if ((keys.has('ArrowRight')|| keys.has('KeyD')) && lane <  2) { lane += 2; keys.delete('ArrowRight'); keys.delete('KeyD'); }
      if (keys.has('Space') || keys.has('ArrowUp') || keys.has('KeyW')) { tryJump(now); keys.delete('Space'); keys.delete('ArrowUp'); keys.delete('KeyW'); }

      player.position.x += (lane - player.position.x) * Math.min(1, settings.camFollow * dt);
      vy += g() * dt; player.position.y += vy * dt; if (player.position.y < 0.5) { player.position.y = 0.5; vy = 0; lastGroundedAt = now; }

      const spd = settings.speed;
      obstacles.forEach(o => o.position.z += spd * dt);
      pickups.forEach(p => p.position.z += spd * dt);
      shields.forEach(s => s.position.z += spd * dt);

      const clean = arr => { for (let i=arr.length-1;i>=0;i--) if (arr[i].position.z > 10) { scene.remove(arr[i]); arr.splice(i,1); } };
      clean(obstacles); clean(pickups); clean(shields);

      if (now - lastSpawnT > 900 && Math.random() < settings.density) { lastSpawnT = now; spawnLine(-28); }

      const isGrounded = grounded();
      for (let i=obstacles.length-1; i>=0; i--) {
        const o = obstacles[i];
        const closeXZ = Math.abs(player.position.x - o.position.x) < 0.9 && Math.abs(player.position.z - o.position.z) < 0.9;
        if (isGrounded && closeXZ) {
          if (now < invulnUntil) break;
          if (shield > 0) { shield--; shieldHud.textContent = String(shield); scene.remove(o); obstacles.splice(i,1); invulnUntil = now + 500; }
          else return gameOver();
        }
      }
      for (let i=pickups.length-1; i>=0; i--) {
        const p = pickups[i];
        if (Math.abs(player.position.x - p.position.x) < 0.9 && Math.abs(player.position.y - p.position.y) < 0.9 && Math.abs(player.position.z - p.position.z) < 0.9) {
          score += 20; scoreEl.textContent = String(score); scene.remove(p); pickups.splice(i,1);
        }
      }
      for (let i=shields.length-1; i>=0; i--) {
        const s = shields[i];
        if (Math.abs(player.position.x - s.position.x) < 0.9 && Math.abs(player.position.y - s.position.y) < 0.9 && Math.abs(player.position.z - s.position.z) < 0.9) {
          shield++; shieldHud.textContent = String(shield); scene.remove(s); shields.splice(i,1);
        }
      }

      timeEl.textContent = ((performance.now()-startTime)/1000).toFixed(1);
    }

    function render(dt) {
      const k = 1 - Math.exp(-settings.camFollow * dt);
      camera.position.lerp(new THREE.Vector3(player.position.x*0.5, 3.3, 7), k);
      camera.lookAt(player.position.x, 0.8, player.position.z - 2);
      if (!isMobile) controls.update();
      renderer.render(scene, camera);
    }

    let last = performance.now();
    function loop(now) { const dt = Math.min(0.05, (now - last)/1000); last = now; update(dt); render(dt); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    // Flow
    async function startGame() { await goFullscreen(); resetWorld(); running = true; menu.style.display='none'; goOv.style.display='none'; pauseOv.style.display='none'; settingsOv.style.display='none'; }
    function togglePause() { if (!running && menu.style.display==='none' && goOv.style.display==='none' && settingsOv.style.display==='none') { running = true; pauseOv.style.display='none'; return; } if (running) { running = false; pauseOv.style.display='flex'; } }
    function toMenu() { running = false; menu.style.display='flex'; goOv.style.display='none'; pauseOv.style.display='none'; settingsOv.style.display='none'; }
    function gameOver() { running = false; finalScoreEl.textContent = String(score); goOv.style.display='flex'; }

    // Buttons
    el('startBtn').onclick = startGame;
    el('pauseBtn').onclick = togglePause;
    el('resumeBtn').onclick = ()=>{ running=true; pauseOv.style.display='none'; };
    el('pauseRestartBtn').onclick = startGame;
    el('pauseMenuBtn').onclick = toMenu;
    el('restartBtn').onclick = startGame;
    el('goMenuBtn').onclick = toMenu;
    el('goSettingsBtn').onclick = ()=>{ setSettingsUI(); goOv.style.display='none'; settingsOv.style.display='flex'; };

    addEventListener('resize', () => { renderer.setSize(innerWidth, innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

    // Block page scroll on keys
    window.addEventListener('keydown', (e)=>{ if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','PageUp','PageDown'].includes(e.code)) e.preventDefault(); }, {passive:false});

    if (!renderer.getContext()) { document.body.innerHTML = '<p style="font:16px system-ui">WebGL failed to initialize. Try Chrome/Edge/Firefox or update graphics drivers.</p>'; }
  </script>
</body>
</html>
